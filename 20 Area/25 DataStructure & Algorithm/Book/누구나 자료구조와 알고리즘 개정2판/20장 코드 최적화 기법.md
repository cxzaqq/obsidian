1. 현재 코드의 효율성 파악
2. 가능한 최상의 실행 시간 생각

이렇게 두 빅 오가 다르면 항상 최상의 빅 오를 달성할 수는 없지만 최적화할 여지가 있다는 뜻이다.

## 룩업(20.3)

"O(1) 시간 안에 원하는 정보를 찾을 수 있다면 알고리즘을 더 빠르게 바꿀 수 있을까?"
보통 새로운 자료 구조를 추가하는 것이 대표적인 방법 중 하나다.(배열 => 해시 테이블)


### 예시
- 두 수의 합 문제
	숫자 배열을 입력 받아 합해서 10(또는 주어진 다른 수)이 되는 두 수가 배열에 있는지를 판단하는 함수
	
```java
public static boolean twoSum(int[] array) {
    for (int i = 0; i < array.length; i++) {
	    for (int j = 0; j < array.length; j++) {
		    if (i !== j && array[i] + array[j] == 10) return true;
	    }
    }
    return false;
}
```
1. 현재 코드의 효율성을 판단해 보자.
	전형적인 중첩 루프이기에 O(n<sup>2</sup>)이다.
2. 가능한 최상의 효율성을 생각해 보자
	배열의 각 수를 무조건 최소 한 번 방문해야 한다. 즉 O(n)보다 좋을 수는 없다. 따라서 최상의 효율을 O(n)이라 생각하고 최적화 해보자.

예를 들어 `[2, 0, 4, 1, 7, 9]` 이런 배열이 있을 때 루프는 `2`부터 시작한다.
2와 어떤 수를 더해서 10이 되는가? => 8이 있는가?
즉 8을 O(1)만에 찾을 수 있는가?  => 해시 사용

```java
import java.util.*;

public static boolean twoSum(int[], int target) {
	Set<Integer> set = new HashSet<>();
	for (int num : array) {
		int complement = target - num;
		if (set.contains(complement)) return true;
		set.add(num);
	}
	return false;
}
```


## 패턴 인식(20.4)

코드 최적화 알고리즘 개발에 전반적으로 쓰이는 가장 유용한 전략 중 하나가 문제에서 패턴을 찾는 방법이다.

### 예시
- 동전 게임
	동전 더미를 가운데 쌓아두고 각 플레이어가 동전 더미에서 차례로 동전을 하나 혹은 두 개 없앤다. 마지막 동전을 없애는 플레이어가 패배한다.

하향식으로 생각하자.

```java
public class CoinGame {
	// 항상 내가 먼저 시작한다고 가정
    public static boolean canWin(int coins, boolean isPlayerTurn = true) {
        if (coins == 0) {
            // 마지막 동전을 없앤 사람이 패배이므로
            return !isPlayerTurn; 
        }

        // 1개 또는 2개 동전을 가져가는 경우 모두 검사
        for (int take = 1; take <= 2; take++) {
            if (coins - take >= 0) {
                // 상대가 질 경우 내가 이김
                if (!canWin(coins - take, !isPlayerTurn)) {
                    return true;
                }
            }
        }

        // 모든 경우 상대가 이기면 나는 짐
        return false;
    }
}
```

1. 현재 코드의 효율성을 판단해 보자.
	 각 경우마다 두 번씩 재귀를 호출하기에 O(2<sup>n</sup>)이다.
2. 가능한 최상의 효율성을 생각해 보자
	우선 n은 숫자 하나에 불과하니 O(1)을 목표로 삼고 최적화 해보자.

패턴을 찾는 유용한 방법 중 하나는 수많은 예제를 생성하는 것이다.

동전 더미가 1~10일 때 누가 승자인지 확인해 보자.

| 동전 개수 | 승자  |
| ----- | --- |
| 1     | 상대  |
| 2     | 나   |
| 3     | 나   |
| 4     | 상대  |
| 5     | 나   |
| 6     | 나   |
| 7     | 상대  |
| 8     | 나   |
| 9     | 나   |
| 10    | 상대  |
패턴이 보이는가?

```java
```java
public class CoinGame {
	// 항상 내가 먼저 시작한다고 가정
    public static boolean canWin(int coins) {
        if ((coins - 1) % 3 == 0) return false;
        else return true;
    }
}
```

이렇게 구현하면 O(1)로 최적화가 가능하다.

## 탐욕 알고리즘(20.5)

### 배열 최댓값(20.5.1)
배열 내에서 가장 큰 수를 찾는 알고리즘을 생각해 보자.

중첩 루프 시 O(n<sup>2</sup>)이고 퀵 정렬 같은 알고리즘을 사용하면 O(nlogn)이다.

그렇다면 탐욕 알고리즘은 어떨까?
```java
public static int getGreatestNum(int[] arr) {
	int greatestNum = arr[0];
	
	for (int n : arr) {
		if (greatestNum < n) greatestNum = n;
	}
	
	return greatestNum;
}
```

처음에 그냥 첫 번째 요소를 가장 큰 수로 가정하고 있다. 이것이 "탐욕스러운(greedy)" 가정이다.
이 방법은 O(n)이면 충분하다.

### 최대 부분 합(20.5.2)
배열의 연속된 부분에서 계산할 수 있는 가장 큰 합을 반환

모든 경우의 수에 대해 확인하면 각 경우를 생성하는 데만 O(n<sup>2</sup>)이 필요하다.

최상의 빅 오는 각 숫자를 최소 한 번씩만 검사하는 O(n)으로 생각하자.

여러 예제를 놓고 보면 패턴이 있는데 그 패턴은 현재까지의 부분합이 음수일 경우 버리고 새로 시작하면 최대를 찾을 수 있다.

```java
public class MaxSubarraySum {
    public static int maxSubarraySum(int[] arr) {
        int maxSum = arr[0];      // 전체 최대합
        int currentSum = arr[0];  // 현재 연속합

        for (int i = 1; i < arr.length; i++) {
            // 현재 수가 이전 합을 포함하는 것보다 큰 경우 선택
            currentSum = Math.max(arr[i], currentSum + arr[i]);

            // 전체 최대합 갱신
            maxSum = Math.max(maxSum, currentSum);
        }

        return maxSum;
    }
}
```

이렇게 하면 O(n)만에 가능하다.

## 자료 구조 변경(20.6)

데이터를 다른 자료 구조에 저장했을 때 어떻게 될지 생각해 보는 것도 유용한 최적화 기법 중 하나다.

### 그룹 정렬

다음 배열을
`[a, c, d, b, b, c, a, d, c, b, a, d]`
다음과 같이 정렬하는 것이다.
`[c, c, c, a, a, a, d, d, d, b, b, b]`
(순서는 상관 없다)

그냥 정렬 알고리즘을 사용한다면 O(nlogn)이다. 하지만 더 빠를 수는 없을까?

각 값을 적어도 한 번은 방문해야 하므로 O(n)을 최상의 빅 오라고 생각하자.

해시 테이블로 데이터를 저장한다면
`[a: 3, c: 3, d: 3, b: 3]` 
O(n)만에 해결할 수 있다.

---
항상 트레이드오프를 생각하자.
