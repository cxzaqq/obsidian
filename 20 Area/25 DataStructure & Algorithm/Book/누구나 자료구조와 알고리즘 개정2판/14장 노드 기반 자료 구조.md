# 연결 리스트

배열은 연속된 메모리에 데이터가 할당되지만 연결 리스트는 연속적이지 않을 수도 있다.
메모리 곳곳에 흩어진 연결된 데이터를 노드라 한다. 노드가 메모리 내에 인접해 있지 않다면 컴퓨터는 어떻게 각 노드가 같은 연결 리스트에 속한 것을 알까?
노드에는 데이터 말고도 추가 정보가 있는데 그것은 다음 노드의 메모리 주소다.

자바는 이미 연결 리스트가 내부적으로 구현되어 있다.

## 읽기

연결 리스트의 특정 요소를 읽기 위해서는 항상 첫 번째 노드부터 읽어야 한다. 즉 최악의 경우 O(n)의 시간 복잡도가 필요하다. 배열 읽기 시 O(1)인 것에 비해 매우 비효율적인 것 같이 보인다.

## 검색

리스트 내 값을 찾아 인덱스를 반환하는 것이다. 배열의 선형 검색에서는 O(n)이었다.
연결 리스트의 검색 속도도 동일하게 O(n)이다.

## 삽입

배열에서의 삽입은 최악의 경우(맨 앞에 요소 추가) O(n)이었다.
연결 리스트는 O(1)만에 가능하다. 다른 값들을 옮길 필요 없이 링크 값만 지정하면 되기 때문이다.
하지만 중간 혹은 끝에 삽입할 경우 연결 리스트는 링크 값을 읽어야 하므로 처음 요소부터 읽기에 O(n)이 필요하다.

## 삭제

삭제도 역시 배열에서는 최악의 경우(맨 앞 요소 삭제) O(n)이지만 연결 리스트에서는 O(1)이다.
하지만 중간 혹은 끝에 삭제할 경우 역시 O(n)이다.

## 배열과 비교

| 연산  | 배열                 | 연결 리스트             |
| --- | ------------------ | ------------------ |
| 읽기  | O(1)               | O(N)               |
| 검색  | O(N)               | O(N)               |
| 삽입  | O(N) (끝에서 하면 O(1)) | O(N) (앞에서 하면 O(1)) |
| 삭제  | O(N) (끝에서 하면 O(1)) | O(N) (앞에서 하면 O(1)) |

이렇게만 보면 연결 리스트를 사용하는 이유가 잘 납득이 안 될 수도 있다.
연결 리스트가 빛을 발하는 경우는 한 리스트를 검사해서 많은 원소를 삭제할 때다. 예를 들어 이메일 주소 리스트를 검토해 유효하지 않으면 모두 삭제하는 함수가 있다고 하자.
배열의 경우 유효하지 않은 것이 나올 때마다 이후 요소들을 모두 왼쪽으로 옮겨야 하지만 연결 리스트의 경우 옮길 필요 없이 링크 값만 변경하면 된다.

즉 연결 리스트는 전체 리스트를 탐색하며 삽입 혹은 삭제를 하기 좋은 자료 구조이다.

# 이중 연결 리스트

이전의 연결 리스트가 다음 노드의 링크 값만 가지고 있었다면 이중 연결 리스트는 이전 노드의 주소 값도 가지고 있는 것이다.

> 자바는 연결 리스트가 구현되어 있다고 했는데 이는 이중 연결 리스트로 구현되어 있다.
> 또한 헤드, 테일 즉 맨 앞 요소, 맨 뒤 요소의 노드를 따로 저장하고 있어서 맨 뒤의 삽입이나 삭제 시 O(1)로 해결이 가능하다.

이를 이용해 자료구조 '큐'를 구현할 수 있다.

> 자바에서 큐는 인터페이스이다. 구현체로는 `LinkedList`, `ArrayDeque`, `PriorityQueue`가 있다.
> 참고: [[09장 스택과 큐로 간결한 코드 생성#큐(9.5)]]
