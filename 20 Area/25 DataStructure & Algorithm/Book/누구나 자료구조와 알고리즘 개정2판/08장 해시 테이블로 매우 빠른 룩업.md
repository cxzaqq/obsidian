
# 해시

해시는 키와 값의 쌍으로 이뤄진 자료 구조이다.


```java
public class Menu {
	Object[][] menu = {
            {"fries", 0.75},
            {"hotdog", 1.5},
            {"soda", 0.6}
        };

	public double getPrice(String foodName) {
        for (Object[] item : menu) {
            if (item[0].equals(foodName)) {
                return (double) item[1];
            }
        }
        return -1.0; // 음식이 없을 경우
    }
}
```

이런 일반 배열의 자료구조에서는 주어진 음식의 가격을 검색하는 데 O(N)이 걸린다. 정렬된 배열이라면 이진 검색을 통해 O(logN)이 걸린다.

이보다 더 좋아질 순 없을까?

```java
import java.util.HashMap;
import java.util.Map;

public class Menu {
    Map<String, Double> menu = new HashMap<>();

    public Menu() {
        menu.put("fries", 0.75);
        menu.put("hotdog", 1.5);
        menu.put("soda", 0.6);
    }

    public double getPrice(String foodName) {
        return menu.getOrDefault(foodName, -1.0);
    }
}
```

해시 자료 구조를 사용하면 O(1)로 줄일 수 있다.
왜일까?

해시의 간단한 예를 들어보면

```
A = 1
B = 2
C = 3
...
```
이렇게 단순하게 문자를 숫자로 매핑할 수 있다.
위 매핑에 따르면 ACE는 135로, CAB는 312로 변환된다.

문자를 가져와 숫자로 변환하는 이러한 과정을 해싱이라 하고 이를 수행하는 것을 해시 함수라 한다.

해시 함수는 이것 외에도 많다. 또 다른 예로는 각 문자에 해당하는 숫자를 가져와 모든 수를 더해 반환하는 것이다.
또는 각 문자에 해당하는 숫자를 모두 곱해 반환하는 방법도 있다.
실제 쓰이는 해시 함수는 이보다 더 복잡하다

## 충돌 해결

자바는 충돌 시
7버전 이하: LinkedList => O(N)
8버전 이상: LinkedList + Red-Black Tree => O(logN)

충돌을 줄이려면 해시 함수 품질이 좋아야 하고, 초기 용량을 적절히 잡아주는 게 좋음

# 효율적인 해시 테이블 만들기

다음 요인에 의해 효율성이 정해진다

- 얼마나 많은 데이터를 저장하는가
- 얼마나 많은 셀을 사용 가능한가
- 어떤 해시 함수를 사용하는가

좋은 해시 함수란 사용 가능한 모든 셀에 데이터를 분산하는 함수다. 데이터를 넓게 퍼뜨릴수록 충돌이 적다.

충돌 조정을 위해 컴퓨터 과학자는 다음과 같은 경험에 기반한 규칙을 세웠다.
저장된 데이터가 7개면 셀은 10개여야 한다.
이 비율을 부하율(load factor)라 부른다. 즉 이상적인 부하율은 0.7이다.(원소 7개 / 셀 10개)

데이터가 추가되기 시작하면 새 데이터가 새로운 셀들에 균등하게 분산되도록 컴퓨터는 셀을 더 추가하고 해시 함수를 바꿔서 해시 테이블을 확장할 것이다.

해시 테이블 내부는 대부분 사용자가 쓰고 있는 컴퓨터 언어가 관리한다. 프로그래밍 언어가 최고의 성능을 내도록 이미 구현이 되어있는 것이다.

# 예시

문제: 한 배열이 다른 배열의 부분 집합인지 알아내기

```java
public class SubsetChecker {

    public static boolean isSubset(String[] arr1, String[] arr2) {
    
	    String[] smaller = arr1.length <= arr2.length ? arr1 : arr2;
        String[] bigger  = arr1.length > arr2.length ? arr1 : arr2;

		for (String e1 : smaller) {
			boolean matched = false;
			for (String e2 : bigger) {
				if(e1.equals(e2)) {
					matched = true;
					break;
				}
			}

		if(!matched) return false;
		}

		return true;
    }
}
```

이 경우 시간 복잡도는 O(N * M)이다.
이제 해시 테이블을 사용해서 효율성을 개선해 보자.

```java
import java.util.HashMap;
import java.util.Map;

public class SubsetChecker {

    public static boolean isSubset(String[] arr1, String[] arr2) {
    
	    String[] smaller = arr1.length <= arr2.length ? arr1 : arr2;
        String[] bigger  = arr1.length > arr2.length ? arr1 : arr2;

		Map<String, Boolean> hashMap = new HashMap<>();

		for (String e : bigger) {
			hashMap.put(e, true)
		}

		for (String e : smaller) {
			if (!hashMap.containsKey(e)) return false;
		}
		
		return true;
    }
}
```

두 항목의 크기를 더한 걸 N이라 하면 이 알고리즘의 시간 복잡도는 O(N)이다.

이전의 O(N * M)에 비하면 엄청난 개선이다.

해시 테이블을 `인덱스`로 사용하는 이 기법은 배열을 여러 번 검색해야 하는 알고리즘에 자주 쓰인다.
알고리즘에서 배열의 값을 계속 검색해야 한다면 매 검색에만 최대 N단계씩 걸리기 때문이다.

해시 테이블은 효율적인 소프트웨어 개발에 필수다. O(1) 읽기와 삽입은 쉽게 따라잡을 수 없느 자료 구조다.
