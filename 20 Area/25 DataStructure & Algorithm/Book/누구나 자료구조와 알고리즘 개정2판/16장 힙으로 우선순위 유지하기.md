
# 우선 순위 큐(16.1)

데이터 삽입 시 데이터를 늘 특정 순서대로 유지한다.

배열 기반의 우선순위 큐에서 데이터 삽입 시 특정 기준을 만족하는 순서를 유지해야 하므로 O(N)이 된다. 기존 큐인 O(1)보다 비효율적이다.

# 힙

삽입이 O(N)인 배열 기반 우선 순위 큐보다 효율적인 구조가 바로 힙이다.

힙에도 여러 종류가 있지만 이진 힙에 대해 다루겠다.

힙은 다음 조건을 따르는 이진 트리다.
- 각 노드의 값은 그 노드의 모든 자손 노드의 값보다 커야 한다.(최대 힙)
- 트리는 완전해야 한다.(완전 트리)

완전 트리는 빠진 노드 없이 모두 채워진 트리. 바닥 줄에는 빈 자리가 있을 수 있는데 오른쪽에는 아무 노드도 없어야 한다.

힙은 조건에 따라 특정 방식으로 정렬되지만 이러한 정렬은 값을 검색하는 데는 전혀 도움이 되지 않는다.
이진 검색 트리에서는 값을 찾을 때 현재 노드보다 작은 값이면 좌측, 큰 값이면 우측 트리를 탐색하지만 힙은 현재 노드보다 큰 값이 좌측일 수도, 작은 값이 우측일 수도 있다.
다만 이진 검색 트리와는 다르게 힙은 트리의 루트 노드가 항상 최대이거나 최소라는 점이다.

## 힙 삽입(16.4)


1. 새 값에 포함하는 노드를 생성하고 바닥 레벨의 가장 오른쪽 노드 옆에 삽입
2. 새 노드와 그 부모 노드 비교
3. 새 노드가 더 크면 스왑
4. 새 노드가 더 클 때까지 반복

간단해 보이지만 마지막 노드 자리를 어떻게 찾을까?

## 힙 삭제(16.6)

1. 마지막 노드를 루트 노드 자리로 옮긴다.
2. 루트 노드를 적절한 자리까지 아래로 트리클링한다. 트리클링 과정은 다음과 같다.
	1. 트리클 노드의 두 자식을 확인해 어느 쪽이 더 큰지 본다.
	2. 트리클 노드가 두 자식 노드 중 큰 노드보다 작으면 큰 노드와 트리클 노드를 스왑한다.
	3. 트리클 노드에 그 노드보다 큰 자식이 없을 때까지 1, 2 반복

삭제할 때는 또 어떻게 마지막 노드를 찾을까?

## 마지막 노드 문제(16.8)

마지막 노드 찾기는 힙 연산의 핵심이고 또한 효율적으로 찾아야 하므로 주로 배열을 사용해 힙을 구현한다.

![[최소힙.png]]

힙을 배열로 구현하는 이유는 마지막 노드 문제를 해결하기 위해서다.
이렇게 배열로 힙을 구현하면 마지막 노드는 항상 배열의 마지막 원소다. 또한 새 노드를 삽입할 때도 배열의 끝에 삽입하면 된다.

- 자바의 경우 이미 `PriorityQueue`가 구현되어 있다.
```java
import java.util.PriorityQueue;

// 최소 힙
public class MinHeapExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        /*
	    최대 힙 사용 방법
	    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
	    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
        */

        // 원소 추가
        minHeap.offer(5);
        minHeap.offer(1);
        minHeap.offer(3);

        // 확인
        System.out.println("peek (최소값): " + minHeap.peek()); // 1

        // poll() 할 때마다 최소값이 제거됨
        while (!minHeap.isEmpty()) {
            System.out.println(minHeap.poll());
        }
    }
}
```

이미 구현되어 있는 기능을 잘 사용하면 되지만 직접 구현해 보자.

```java
public class MinHeap {
	private int[] heap;
	private int size;
	
	public MinHeap(int capacity) {
		heap = new int[capacity];
		size = 0;
	}
	
	// 부모, 자식 인덱스 계산
	private int parent(int i) return (i - 1) / 2;
	private int leftChild(int i) return  2 * i + 1;
	private int rightChild(int i) return 2 * i + 2;
	
	// 원소 추가
	public void insert(int value) {
		if (size == heap.length) throw new RuntimeException("Heap is full");
		heap[size] = value;
		siftUp(size); // 올바른 위치로 올리기
		size++;
	}
	
	// 최소값 확인
	public int peek() {
		if (size == 0) throw new RuntimeException("Heap is empty");
		return heap[0];
	}
	
	// 최소값 제거
	public int poll() {
		if (size == 0) throw new RuntimeException("Heap is empty");
		int root = heap[0];
		heap[0] = heap[size - 1]; // 마지막 요소를 루트로
		size--;
		siftDown(0); // 내려가면서 정렬
		return root;
	}
	
	// 위로 올리기
	private void siftUp(int i) {
		while (i > 0 && heap[i] < heap[parent(i)]) {
			swap(i, parent(i));
			i = parent(i);
		}
	}
	
	// 아래로 내리기
	private void siftDown(int i) {
		int smallest = i;
		int left = leftChild(i);
		int right = rightChild(i);
		
		// 두 자식 중 더 작은 값을 smallest에 넣는다.
		if (left < size && heap[left] < heap[smallest]) {
			smallest = left;
		}
		if (right < size && heap[right] < heap[smallest]) {
			smallest = right;
		}
		
		// 만약 부모(i)가 가장 작다면 종료
		// 아니면 부모와 더 작은 자식을 교환 후 해당 위치에서 다시 검사
		if (smallest != i) {
			swap(i, smallest);
			siftDown(smallest);
		}
	}
	
	private void swap(int i, int j) {
		int tmp = heap[i];
		heap[i] = heap[j];
		heap[j] = tmp;
	}
	
	public boolean isEmpty() {
		return size == 0;
	}
}
```


## 힙 vs 정렬된 배열(16.7)

|     | 정렬된 배열 | 힙       |
| --- | ------ | ------- |
| 삽입  | O(N)   | O(logN) |
| 삭제  | O(1)   | O(logN) |
O(1)이 엄청 빠르긴 하지만 O(logN)도 매우 빠르다. 이에 비해 O(N)은 매우 느리다. 그리고 보통 우선 순위 큐가 일반적으로 삽입과 삭제를 거의 비슷한 비율로 수행한다는 점에서 보통 힙을 선택한다.
