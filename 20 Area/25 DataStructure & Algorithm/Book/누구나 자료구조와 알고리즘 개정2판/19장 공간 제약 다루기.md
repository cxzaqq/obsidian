대량의 데이터를 다루거나 메모리가 제한된 작은 장치를 프로그래밍 할 때는 공간 복잡도가 매우 중요하다.

시간 복잡도와 마찬가지로 공간 복잡도도 표현할 때 빅 오 표기법을 사용한다.

시간 복잡도는 "데이터 원소가 N개일 때 알고리즘에 몇 단계가 필요한가?"였다면 공간 복잡도는 "데이터 원소가 N개일 때 알고리즘은 메모리 단위를 얼마나 소모할까?"이다.
기존 데이터가 아닌 새로 생성되는 데이터만 고려한다.


다음 구현이 다른 같은 알고리즘을 보자

```java
import java.util.*;

public static boolean hasDuplicateValue1(int[] array) {
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array.length; j++) {
            if (i != j && array[i] == array[j]) {
                return true;
            }
        }
    }
    return false;
}

public static boolean hasDuplicateValue2(int[] array) {
    Set<Integer> existingValues = new HashSet<>();
    for (int i = 0; i < array.length; i++) {
        if (!existingValues.contains(array[i])) {
            existingValues.add(array[i]);
        } else {
            return true;
        }
    }
    return false;
}

public static boolean hasDuplicateValue3(int[] array) {
    Arrays.sort(array);
    for (int i = 0; i < array.length - 1; i++) {
        if (array[i] == array[i + 1]) {
            return true;
        }
    }
    return false;
}
```

다음 알고리즘들의 시간, 공간 복잡도를 측정해 보자

| 방식  | 시간 복잡도           | 공간 복잡도  |
| --- | ---------------- | ------- |
| 1   | O(n<sup>2</sup>) | O(1)    |
| 2   | O(n)             | O(n)    |
| 3   | O(nlogn)         | O(logn) |
근본적으로 각 상황마다 최소 허용 속도와 메모리 한도를 알아야 한다. 제약을 이해해야 다양한 알고리즘 중 선택할 수 있고 속도와 메모리 요구사항에 맞게 효율성을 유지할 수 있다.
