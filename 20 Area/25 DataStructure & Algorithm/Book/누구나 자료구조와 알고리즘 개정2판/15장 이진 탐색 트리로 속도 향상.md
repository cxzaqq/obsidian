데이터를 자주 정렬해야 한다면 다시 정렬할 일이 없게 데이터를 항상 정렬된 순서로 유지하는 것이 합리적일 것이다.

가장 좋은 자료구조는 무엇일까?
정렬된 배열? 삽입, 삭제 시 비효율적이다.
해시 테이블? 전반적으로 좋은 성능이지만 정렬되지 않는다.

# 트리

> 자바에서는 일반적인 트리가 따로 구현되어 있지 않다.
> `TreeSet`, `TreeMap`이 있긴 하지만 이는 `Red-Black Tree`기반으로 구현되어 있다.

## 이진 탐색 트리

트리에서 제약이 추가되었다.

- 각 노드의 자식은 0, 1, 2 개 중 하나이다.
- 한 노드의 왼쪽 자손은 그 노드보다 작은 값만 가질 수 있다. 오른쪽 자손은 그 노드보다 큰 값만 가질 수 있다.

### 검색

1. 루트 노드의 값을 확인한다.
2. 찾고 있는 값이 현재 노드보다 작으면 왼쪽 하위 트리를 검색한다.
3. 찾고 있는 값이 현재 노드보다 크면 오른쪽 하위 트리를 검색한다.
4. 찾고 있는 값을 찾거나 바닥에 닿을 때까지 반복

### 이진 탐색 트리의 효율성

각 단계마다 검색할 대상이 남은 노드의 반으로 줄어든다.
즉 O(logn)이다.

### 삽입

이진 탐색 트리는 삽입에서 굉장히 강력하다.
검색하면서 적절한 위치를 찾은 후 해당 위치에 노드를 삽입하면 되므로 O(logn)이다.

### 삭제

삭제할 노드의 자식이 없으면 바로 삭제
자식이 하나 있을 경우 노드를 삭제 후 그 위치에 자식 노드 연결
자식이 둘 있을 경우 해당 노드와 그 자손을 오름차순 정렬했을 때 해당 노드 다음으로 큰 노드를 후속자 노드라 한다. 후속자 노드를 삭제된 노드 자리에 넣는다.

컴퓨터는 어떻게 후속자 노드를 찾을까?

삭제된 값의 오른쪽 자식을 방문해서 그 자식의 왼쪽 자식을 따라 계속 방문하여 더 이상 왼쪽 자식이 없을 때까지 내려간다. 바닥 값이 후속자 노드이다.

하지만 오른쪽 자식이 있는 후속자 노드의 경우 어떻게 할까?
이때는 그냥 넣으면 연결이 끊기게 된다. 이 경우 후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.

정리하면
- 삭제할 노드의 자식이 없으면 바로 삭제
- 자식이 하나면 노드를 삭제하고 자식을 해당 위치에 넣는다
- 자식이 둘이면 삭제된 노드를 후속자 노드로 대체한다.
- 만약 후속자 노드에 오른쪽 자식이 있으면 후속자 노드를 삭제된 위치에 넣은 후 후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.

시간 복잡도는 삭제할 노드 검색에 O(logn)
자식수에 따라 처리
- 0자식: O(1) (삭제)
- 1자식: O(1) (삭제)
- 2자식: O(logn) (탐색) + O(1) (삭제)
즉 O(logn)이다.

### 순회

순서대로 출력하고 싶을 경우(중위 순회를 사용)
참고: [[12.2 데이터 입출력 구현2#Inorder 운행법 (B)]]

모든 노드를 탐색하므로 O(n) 필요

### 코드 구현

```java
// 노드 클래스
class TreeNode {
	String value;
	TreeNode left;
	TreeNode right;

	TreeNode(String value) {
		this.value = value;
	}
}

// 이진 탐색 트리 클래스
class BinarySearchTree {
	private TreeNode root;

	// 삽입
	public void insert(String value) {
		root = insertRecursive(root, value);
	}

	private TreeNode insertRecursive(TreeNode node, String value) {
		if (node == null) return new TreeNode(value);

		int cmp = value.compareTo(node.value);
		if (cmp < 0) {
			node.left = insertRevursive(node.left, value);
		} else if (cmp > 0) {
			node.right = insertRecursive(node.right, value);
		}
		// 같으면 삽입 X
		return node;
	}

	// 검색
	puboic boolean search(String value) {
		return searchRecursive(root, value);
	}

	private boolean searchRecursive(TreeNode node, String value) {
		if (node == null) return false;
		int cmp = value.compareTo(node.value);
		if (cmp == 0) return true;
		return cmp < 0 ? searchRecursive(node.left, value) : searchRecursive(node.right, value);
	}

	// 삭제
	public void delete(String value) {
		root = deleteRevursive(root, value);
	}

	private TreeNode deleteRecursive(TreeNode node, String value) {
		if (node == null) return null;

		int cmp = value.compareTo(node.value);
		if (cmp < 0) {
			node.left = deleteRecursive(node.left, value);
		} else if (cmp > 0) {
			node.right = deleteRecursive(node.right, value);
		} else {
			// 자식 없음
			if (node.left == null && node.right == null) return null;

			// 자식 1개
			if (node.left == null) return node.right;
			if (node.right == null) return node.left;

			// 자식 2개
			node.value = findMin(node.right);
			node.right = deleteRecursive(node.right, node.value);
		}
		return node;
	}

	private findMin(TreeNode node) {
		while (node.left != null) node = node.left;
		return node.value;
	}

	// 중위 순회
	public void inorder() {
		inorderRecursive(root);
		System.out.println();
	}

	private void inorderRecursive(TreeNode node) {
		if (node != null) {
			inorderRecursive(node.left);
			System.out.print(node.value + " ");
			inorderRecursive(node.right);
		}
	}
}

/*
// 순회 예시
      Mango
     /     \
 Banana   Peach
  /   \
Apple  Cherry


i(Mango)
=>i(Banana)
==>i(Apple)
===>i(null)
"Apple"
===>i(null)
"Banana"
==>i(Cherry)
===>i(null)
"Cherry"
===>i(null)
"Mango"
=>i("Peach")
==>i(null)
"Peach"
==>i(null)
*/
```
