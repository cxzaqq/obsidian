빠른 코드를 작성하는 첫 번째 단계는 자료구조가 무엇인지, 다양한 자료 구조가 코드 속도에 어떤 영향을 미치는지 이해하는 것이다.

# 속도 측정(1.3)
순수하게 시간 관점에서 연산이 얼마나 빠른가가 아니라 얼마나 많은 단계가 필요한지를 논해야 함

하드웨어의 성능에 따라 같은 코드도 수행 시간이 달라질 수 있음. => 시간을 기준으로 속도를 측정하면 신뢰할 수 없다.
즉 단계 수 측정이 연산 속도를 분석하는 핵심 비결임

# 자료구조 연산(1.2.1)
대부분의 자료 구조는 네 가지 연산을 사용한다.

읽기: 특정 위치 찾기
검색: 특정 값 찾기
삽입: 새로운 값 추가
삭제: 값 제거

# 배열(1.2)
## 읽기(1.4)
배열 내 특정 인덱스에 어떤 값이 들어 있는지 찾는 것

다음 특성들을 이해하자.
- 배열 선언 시 연속된 메모리 공간을 할당.
- 컴퓨터는 모든 메모리 주소에 한 번에 접근 가능. 예를 들어 1063번지에 있는 값을 알고 싶다 => 1부터 보는 게 아니라 1063에 바로 접근
- 배열 할당 시 어떤 메모리 주소에서 시작하는가도 기록함. 즉 어떤 배열의 3번째 인덱스를 가져오라는 명령을 입력하면 (배열의 시작 메모리 주소 + 3) 해당 주소로 바로 접근하여 읽는다

따라서 배열 읽기는 매우 효율적인 연산이다.

배열의 크기와 상관 없이 항상 한 단계가 걸린다.
## 검색(1.5)
특정 값이 있는지, 어떤 인덱스에 있는지 찾는 것
읽기는 매우 빠르지만 검색은 훨씬 오래 걸린다.
메모리 주소에 한 번에 접근하지만 그 값은 바로 알지 못한다.
즉 값을 찾으려면 찾을 때까지 배열 내 모든 메모리 값을 봐야 한다.

선형 검색에서 최악의 경우 배열의 크기(N)만큼의 단계가 걸린다.

## 삽입(1.6)
어디에 데이터를 삽입하는가에 따라 효율성이 다르다.

- 맨 뒤에 넣을 경우
	한 단계만 필요하다.
- 중간에 넣을 경우
	중간 이후의 값들을 모두 오른쪽으로 한 단계씩 미는 단계들 + 새 값 추가하는 한 단계
- 맨 앞에 넣을 경우
	최악의 시나리오. 배열의 크기가 N일 때 N+1 단계가 필요하다

## 삭제(1.7)
어디에 있는 데이터를 삭제하는가에 따라 효율성이 다르다.

- 맨 뒤 삭제
	한 단계만 필요하다.
- 중간 삭제
	삭제하는 한 단계 + 중간 이후의 값들을 모두 왼쪽으로 한 단계씩 미는 단계들
- 맨 앞 삭제
	최악의 시나리오. 배열의 크기가 N일 때 N 단계가 필요하다

> [!자바의 경우]
배열 선언 시 크기를 지정해야 하기에 새로운 배열을 선언 후 재할당을 해야 한다.
(비효율적 => 한 번 늘릴 때 현재 용량의 2배로 늘리기 전략을 보통 사용.)
> 
혹은 자바가 제공하는 동적 배열인 `ArrayList`를 사용하는데 내부적으로 위와 같은 방식(새 배열 생성 + 복사)을 사용하여 자동으로 크기를 늘려준다.(자바는 1.5배 사용한다고 나옴)
`int newCapacity = oldCapacity + (oldCapacity >> 1); // = oldCapacity * 1.5`
>
삽입 시
용량 부족 => 현재 용량의 1.5배로 새 배열을 생성 -> 기존 배열을 새 배열에 복사 -> 요소들을 밀어내고 새 값 삽입
용량 부족X => 요소들을 밀어내고 새 값 삽입
>
삭제 시
삭제한 요소 뒤의 모든 요소를 왼쪽으로 복사 -> 마지막 요소를 `null`로 설정(GC의 대상이 되도록)
`ArrayList`는 원소로 자바의 primitive 타입을 받을 수 없는데 만약 이를 원한다면 직접 만들면 된다.
>
`ArrayList`의 원소는 primitive 값이 아닌 객체를 참조하는데 이 객체들은 물리적으로 연속적이지 않다. 연속적인 것은 참조하는 주소값이 연속적인 것.


# 집합(1.8)

중복 값을 허용하지 않는 자료 구조(배열 기반의 집합을 다룰 예정)

이 간단한 제약으로 인해 네 주요 연산 중 하나에서 집합의 효율성이 크게 달라진다.

읽기, 검색, 삽입은 배열과 동일하다

삽입의 경우 크게 달라지는데
모든 인덱스에 대한 값을 검사 후 삽입해야 한다.

즉 기존 삽입에서 배열의 크기인 N단계의 검색이 추가로 필요하다.


배열과 집합에서처럼 자료 구조의 성능 측정은 단계 수를 구하는 게 핵심이다.
프로그램이 부하를 감당할지 중단될지는 알맞은 자료구조를 선택했느냐에 따라 바뀔 수 있다.











