이전에 학습한 버블 정렬, 선택 정렬, 삽입 정렬과 같은 많은 정렬 알고리즘은 실제 정렬 시에는 사용하지 않는다. 컴퓨터 언어에는 대부분 내장 정렬 함수가 있어 사용자가 직접 구현할 필요가 없다. 컴퓨터 언어 대다수가 내부적으로 채택한 정렬 알고리즘은 바로 퀵 정렬이다.
퀵 정렬은 분할이라는 개념에 기반한다.

> 자바는 타입에 따라 정렬의 방식이 다르다.
> 원시 타입 배열: Dual-Pivot Quicksort(두 개의 피벗 사용, 3분할 => 깊이가 줄어든다), (불안정: 같은 값의 상대 순서 보장 x)
> 객체 배열: TimSort(병합 정렬 + 삽입 정렬), (안정: 같은 값의 상대 순서 유지)
> 
> 왜 다른 방식을 채택했을까?
> 원시 타입 배열의 경우 메모리 절약 + 속도가 중요하기에 in-place 퀵 정렬을 선택했고 객체 배열은 순서의 안정성이 중요하기에 TimSort를 선택했다.


# 퀵 정렬
## 분할

배열에서 임의의 수(pivot)를 가져와 피벗보다 작은 수는 왼쪽에 피벗보다 큰 수는 오른쪽에 두는 것이다.

피벗 설정 후 정렬을 위해 두 포인터를 사용하는데 피벗을 제외한 배열에서 포인터 하나는 가장 왼쪽에, 다른 하나는 가장 오른쪽에 둔다. 이후

1. 왼쪽 포인터를 한 셀씩 오른쪽으로 옮기면서 피벗보다 크거나 같은 값에 도달하면 멈춘다.
2. 오른쪽 포인터를 한 셀씩 왼쪽으로 옮기면서 피벗보다 작거나 같은 값에 도달하면 멈춘다. 혹은 배열 맨 앞에 도달해도 멈춘다.
3. 오른쪽 포인터가 멈춘 후에는 둘 중 하나를 선택한다. 왼쪽 포인터가 오른쪽 포인터에 도달하거나 넘어섰으면 다음 단계로 넘어가고 그렇지 않을 경우 왼쪽 포인터와 오른쪾 포인터가 가리키고 있는 값을 교환 후 다시 처음부터 실행한다.
4. 끝으로 왼쪽 포인터가 현재 가리키고 있는 값과 피벗을 교환한다.

분할이 끝나면 피벗 왼쪽에 있는 값은 모두 피벗보다 작고 피벗 오른쪽에 있는 값은 모두 피벗보다 크다.
아직 완전히 정렬되진 않았지만 피벗 자체는 배열 내에서 올바른 위치에 있는 것이다.

## 정렬

분할이 끝나면 피벗을 기준으로 배열을 나눈다. 이후 각 하위 배열들을 다시 분할 과정을 거친다. 하위 배열이 원소가 0개 또는 1개이면 아무것도 하지 않는다.

## 코드 구현

```java
public class QuickSort {

	public static void quickSort(int[] arr, int left, int right) {
		if (left >= right) return;

		int pivotIndex = partition(arr, left, right);

		// 좌측 정렬
		quickSort(arr, left, pivotIndex - 1);
		// 우측 정렬
		quickSort(arr, pivotIndex + 1, right);
	}

	// 피벗 기준으로 나누기
	private static int partition(int[] arr, int left, int right) {

		// 마지막 원소를 피벗으로 선택
		int pivot = arr[right];
		// 피벗보다 작은 값들의 마지막 위치
		int i = left - 1;

		for (int j = left; j < right; j++) {
			if (arr[j] <= pivot) {
				i++;
				swap(arr, i, j);
			}
		}

		// 피벗을 중앙으로 이동
		swap(arr, i + 1, right);
		// 피벗 위치 반환
		return i + 1;
	}

	private static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
}
```

## 퀵 정렬의 효율성

| 상황  | 설명                                                                            | 시간 복잡도           |
| --- | ----------------------------------------------------------------------------- | ---------------- |
| 평균  | 각 분할 단계에서 배열을 거의 반으로 나눈다고 가정<br>한 번의 분할에 O(n) (모든 원소 비교)<br>분할 단계가 O(logn) 깊이 | O(nlogn)         |
| 최악  | 한 쪽으로 치우친 경우<br>한 번의 분할에 O(n) (모든 원소 비교)<br>분할 단계가 n 깊이                       | O(n<sup>2</sup>) |
| 최선  | 항상 배열이 정확히 반으로 나눠질 때<br>한 번의 분할에 O(n) (모든 원소 비교)<br>분할 단계가 O(logn) 깊이         | O(nlogn)         |
참고: [[Big-O.png]]

# 퀵 셀렉트

무작위로 정렬된 배열이 있을 때 두 번째로 작은 값을 알고 싶을 때 모든 요소를 정렬 후 값을 찾아도 되겠지만 정렬을 하지 않고 더 나은 성능으로 찾아내는 방법이 있다.

예를 들어 요소가 8개인 배열에서 두 번째로 작은 값을 찾고 싶다고 하자.
먼저 전체 배열을 분할하면 피벗은 중간 부분에 있을 것이다.
그렇다면 두 번째로 작은 값은 피벗 좌측에 있을 것이다.
이후 좌측만 또 분할하고 이 과정을 반복해서 피벗이 두 번째 있을 때 그것이 바로 두 번째로 작은 값이다.

## 코드 구현

```java
public class QuickSelect {

	public static int quickSelect(int[] arr, int left, int right, int k) {

		// 배열이 하나 남으면 반환
		if (left == right) return arr[left];

		int pivotIndex = partition(arr, left, right);

		if (k == pivotIndex) {
			return arr[k];
		} else if (k < pivotIndex) {
			return quickSelect(arr, left, pivotIndex - 1, k);
		} else {
			return quickSelect(arr, pivotIndex + 1, right, k);
		}
	}

	private static int partition(int[] arr, int left, int right) {

		// 마지막 원소를 피벗으로 선택
		int pivot = arr[right];
		// 피벗보다 작은 값들의 마지막 위치
		int i = left - 1;
		for (int j = left; j < right; j++) {
			if (arr[j] <= pivot) {
				i++;
				swap(arr, i, j);
			}
		}

		// 피벗을 중앙으로 이동
		swap(arr, i + 1, right);
		// 피벗 위치 반환
		return i + 1;
	}

	private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

## 퀵 셀렉트의 효율성

| 상황  | 설명                                                                                                                                                      | 시간 복잡도           |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| 평균  | 각 분할 단계에서 배열을 거의 반으로 나눈다고 가정<br>한 번의 분할에 O(n) (모든 원소 비교)<br>분할 시 한 쪽 부분만 재귀 호출<br><br>n + n/2 + n/4 + n/8 + ...<br>= n(1 + 1/2 + 1/4 + 1/8 + ...) <= 2n | O(n)             |
| 최악  | 한 쪽으로 치우친 경우<br>한 번의 분할에 O(n) (모든 원소 비교)<br>분할 단계가 n 깊이                                                                                                 | O(n<sup>2</sup>) |
