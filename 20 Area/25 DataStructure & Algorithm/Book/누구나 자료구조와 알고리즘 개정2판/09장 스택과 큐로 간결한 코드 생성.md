# 스택(9.1)

제약이 있는 배열

- 스택의 끝에만 데이터 삽입, 삭제 가능
- 스택의 마지막 원소만 읽기 가능

Last In First Out


자바에서는 스택이 구현되어있다.

```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();

        stack.push("A"); // A 추가
        stack.push("B"); // B 추가
        stack.push("C"); // C 추가

        System.out.println(stack.peek());  // C 출력 (맨 위 요소 확인)
        System.out.println(stack.pop());   // C 제거 및 출력
        System.out.println(stack.pop());   // B 제거 및 출력
        System.out.println(stack.empty()); // false (스택에 A가 남아있음)
        System.out.println(stack.pop());   // A 제거 및 출력
        System.out.println(stack.empty()); // true (스택 비어있음)
    }
}
```

## 자바에서 스택의 내부 구조

`Stack<E>`는 `Vector<E>` 클래스를 상속받은 클래스로, `Vector`의 메서드들을 활용해 스택 기능을 구현.
    
`Vector`는 내부적으로 동적 배열 (dynamic array) 을 사용. 즉, 요소를 추가할 때마다 배열 크기를 늘리거나 줄이면서 관리.
    
결국 `Vector`가 관리하는 동적 배열 위에서 작동.

> [!NOTE] Vector
> 자바에서 제공하는 동적 배열 기반의 자료구조 클래스.
(크기가 자동으로 늘어나는 배열)
>
내부적으로 일반 배열을 사용하지만 사용자가 원소를 추가할 때마다 자동으로 크기를 늘려준다.
>
`ArrayList`와 비슷하지만 `Vector`는 모든 메서드가 동기화 처리되어 있어 Thread-safe하고 1.5배씩 증가하는 `ArrayList`와는 다르게 2배씩 증가함.
즉 멀티 스레드 환경에서 `synchronized` 키워드 덕분에 안전하게 동작함
but 단일 스레드 환경에서는 성능 저하가 발생할 수 있음.

스택은 결국 메서드 동기화 처리 때문에 성능 면에서 단점이 있을 수 있다.

따라서 최근에는 `ArrayDeque`를 스택처럼 사용하는 게 더 권장된다.


> [!NOTE] ArrayDeque
> 내부에 원형 배열을 가지고 있다.
> 배열 끝에 도달해도 처음으로 돌아가면서 빈 공간을 활용한다.
> 배열 크기가 부족하면 내부적으로 크기를 2배로 늘려 재배치한다.
> 요소 추가/삭제 시 배열 복사가 최소화되어 매우 빠르다.
> 
> 그렇다면 왜 스택 대신 권장될까?
> - 비동기화
> - 성능이 훨씬 빠름
> - 스택은 오래된 클래스이다.
> 
> 자바 공식 문서에서도 스택을 구현 시 `ArrayDeque`를 권장
> 
> ```
> A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example:
> ```
> `Deque<Integer> stack = new ArrayDeque<Integer>();`
> https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html


## 예시(9.3)

문제: 괄호가 유효한지 검사

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class BracketCheckerWithDetail {

    public enum ErrorType {
        NO_ERROR,
        OPEN_WITHOUT_CLOSE,        // 1. 여는 괄호는 있는데 닫는 괄호가 없는 경우
        CLOSE_WITHOUT_OPEN,        // 2. 여는 괄호가 앞에 없는데 닫는 괄호가 나온 경우
        MISMATCHED_PAIR            // 3. 닫는 괄호 바로 앞에 나오는 여는 괄호가 종류가 다른 경우
    }

    public static class Result {
        public final boolean isValid;
        public final ErrorType errorType;
        public final int position;  // 문제 발생 위치 (문자 인덱스)
        public final char problematicChar;  // 문제 있는 괄호 문자

        public Result(boolean isValid, ErrorType errorType, int position, char problematicChar) {
            this.isValid = isValid;
            this.errorType = errorType;
            this.position = position;
            this.problematicChar = problematicChar;
        }

        @Override
        public String toString() {
            if (isValid) {
                return "괄호가 모두 올바르게 맞았습니다.";
            }
            switch (errorType) {
                case OPEN_WITHOUT_CLOSE:
                    return String.format("열렸지만 닫히지 않은 괄호 '%c' 가 위치 %d 에 있습니다.", problematicChar, position);
                case CLOSE_WITHOUT_OPEN:
                    return String.format("닫는 괄호 '%c' 가 열리지 않은 상태에서 위치 %d 에 나타났습니다.", problematicChar, position);
                case MISMATCHED_PAIR:
                    return String.format("닫는 괄호 '%c' 가 위치 %d 에 있는데, 바로 앞 열린 괄호와 쌍이 맞지 않습니다.", problematicChar, position);
                default:
                    return "알 수 없는 오류입니다.";
            }
        }
    }

    public static Result checkBrackets(String input) {
        Deque<BracketPosition> stack = new ArrayDeque<>();

        for (int i = 0; i < input.length(); i++) {
            char ch = input.charAt(i);
            switch (ch) {
                case '(':
                case '{':
                case '[':
                    stack.push(new BracketPosition(ch, i));
                    break;

                case ')':
                case '}':
                case ']':
                    if (stack.isEmpty()) {
                        // 2. 여는 괄호가 없는데 닫는 괄호가 나온 경우
                        return new Result(false, ErrorType.CLOSE_WITHOUT_OPEN, i, ch);
                    }
                    BracketPosition openBracket = stack.pop();
                    if (!isMatchingPair(openBracket.bracket, ch)) {
                        // 3. 닫는 괄호 바로 앞에 나오는 여는 괄호가 종류가 다른 경우
                        return new Result(false, ErrorType.MISMATCHED_PAIR, i, ch);
                    }
                    break;
                default:
                    // 괄호 아닌 문자 무시
                    break;
            }
        }

        if (!stack.isEmpty()) {
            // 1. 여는 괄호는 있는데 닫는 괄호가 없는 경우
            BracketPosition openBracket = stack.pop();
            return new Result(false, ErrorType.OPEN_WITHOUT_CLOSE, openBracket.position, openBracket.bracket);
        }

        return new Result(true, ErrorType.NO_ERROR, -1, '\0');
    }

    private static boolean isMatchingPair(char open, char close) {
        return (open == '(' && close == ')')
            || (open == '{' && close == '}')
            || (open == '[' && close == ']');
    }

    private static class BracketPosition {
        char bracket;
        int position;
        BracketPosition(char bracket, int position) {
            this.bracket = bracket;
            this.position = position;
        }
    }
}
```

# 큐(9.5)

제약이 있는 배열

- 큐의 끝에서만 데이터 삽입 가능
- 큐의 앞에서만 데이터 삭제 가능
- 큐의 앞에서만 데이터 읽기 가능

First In First Out

자바에서는 큐라는 인터페이스가 있고 이를 구현하는 여러 클래스가 있다.

| 구현체                   | 내부 자료 구조              | 권장 상황     |
| --------------------- | --------------------- | --------- |
| LinkedList            | Doubly Linked List 기반 | 양방향 큐     |
| ArrayDeque            | Circular Array 기반     | 단순 FIFO 큐 |
| PriorityQueue         | Heap 기반               | 우선순위 큐    |
| ConcurrentLinkedQueue | 단방향 연결리스트 기반          | 스레드 안전 큐  |

공식 문서 및 현업에서는 일반적으로 `ArrayDeque`를 기본 스택/큐로 권장
`LinkedList`는 연결 리스트 특성상 메모리 오버헤드가 있고 캐시 적중률이 떨어져 성능이 상대적으로 낮다.
```java
import java.util.ArrayDeque;
import java.util.Queue;

public class ArrayDequeQueueExample {
    public static void main(String[] args) {
        Queue<Integer> queue = new ArrayDeque<>();

        queue.offer(1);
        queue.offer(2);
        queue.offer(3);

        System.out.println(queue.poll()); // 1
        System.out.println(queue.peek()); // 2
    }
}
```

스택과 큐는 자주 사용되는 자료 구조이다. 잘 알아두자.
