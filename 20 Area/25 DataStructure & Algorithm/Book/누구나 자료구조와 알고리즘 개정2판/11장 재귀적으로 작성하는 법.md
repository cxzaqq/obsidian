재귀는 하향식 방식을 구현하는 데 탁월하다.
하향식 전략을 재귀적으로 작성해서 구현할 때는 계산이 실제 어떻게 이뤄지는지 세부적인 내용은 무시해도 된다. "세부 사항은 하위 문제에서 다루게 두자"

먼저 하향식으로 생각하는 방법을 배워보자.
1. 작성 중인 함수를 이미 누군가 구현해 놓았다고 가정
2. 문제의 하위 문제를 찾기
3. 하위 문제에 함수를 호출하면 어떻게 되는지 보고 거기부터 시작하기

예를 들어 문자열을 뒤집어 출력하는 문제를 살펴 보자.
문자열 "abc"가 있을 때 "cba"가 출력된다.
1. 누군가 이미 `reverse(String str)`을 작성해 놨다고 가정하자
2. 하위 문제는 `reverse("bcde")`이다. 이를 표현하면 `reverse(str.substring(1)) + str[0]`이다.
3. 구현해 보자.
```java
public static String reverse(String str) {
    if (str.length() == 1) return str;
    return reverse(str.substring(1)) + str.charAt(0);
}
/*
reverse("abc") -> reverse("bc") + "a"
reverse("bc") -> reverse("c") + "b"
reverse("c") -> "c"
*/
```

효율성을 생각하면 for문이 훨씬 효율적이다.

재귀는 매 호출마다 호출 스택이 쌓임.
`substring`은 내부적으로 새로운 문자열 객체를 계속 생성함

for문은 한 번의 루프에서 모든 처리가 끝남.
메서드 호출 비용 없음.
메모리 사용도 최소화.

그냥 이게 제일 간단하고 효율적임
```java
new StringBuilder(str).reverse().toString();
```

그냥 재귀 연습임

## 계단 문제(11.4)

N개 짜리 계단이 있고 한 번에 1, 2, 3 계단까지 오를 수 있을 때 끝까지 올라가는 경로는 몇 개일까?

5계단만 되어도 생각하기가 매우 복잡하지만 이를 하향식으로 사고하면 간단하게 해결할 수 있다.

N이 11일 때를 생각해 보자.
첫 번째 하위 문제는 N이 10일 때이다. 10 계단의 경로 수를 알면 11 계단의 경로를 알 수 있다. 하지만 9 번째나 8 번째 계단에서도 한 번에 마지막 계단으로 갈 수 있기에 완벽한 답은 아니다.

조금만 더 생각해 보면 10 -> 11 경로일 경우 9 -> 11 경로는 따르지 않을 것이다. 반대로 9 -> 11 경로일 경우 10 번째 계단은 거치지 않을 것이다.

따라서 꼭대기까지 가는 경로 수는 최소한 10번째 계단까지 가는 경로 수에 9번째 계단까지 가는 경로 수를 더한 값이다.

또한 한 번에 3 계단도 오를 수 있으므로 8 -> 11의 경로도 포함해야 한다.

결론적으로 꼭대기까지 가는 경로 수는 적어도 10, 9, 8 까지의 모든 경로 수의 합이다.

간단하게 표현하면
`getNumOfPath(N - 1) + getNumOfPath(N - 2) + getNumOfPath(N - 3)`
이렇게 표현할 수 있고 이제 기저 조건을 파악해 보자.

기저 조건을 파악하기 어려울 때는 조건을 전부 적어보는 것도 방법이다.

```java
public static int getNumOfPath(n) {
	if (n <= 0) return 0;
	if (n == 1) return 1;
	if (n == 2) return 2;
	if (n == 3) return 4;
	return getNumOfPath(n - 1) + getNumOfPath(n - 2) + getNumOfPath(n - 3);
}
```

이제 정리해 보자.
n이 1일 때는 당연히 1이므로 그대로 둔다.
n이 2일 때는 2를 반환해야 하지만 이 기저 조건은 굳이 명시하지 않아도 된다. `getNumOfPath(2)`가 `getNumOfPath(1) + getNumOfPath(0) + getNumOfPath(-1)`이기 때문이다.

그렇다면 `getNumOfPath(0)`이 1을 반환하면 된다.

```java
if (n < 0) return 0;
if (n == 0 || n == 1) return 1;
```

`getNumOfPath(3)`은 4를 반환해야 한다. 즉 `getNumOfPath(2) + getNumOfPath(1) + getNumOfPath(0)`이 4이다. 이는 기존의 조건을 충분히 만족한다.

최종적으로
```java 
public static int getNumOfPath(n) {
	if (n < 0) return 0;
	if (n == 0 || n == 1) return 1;
	return getNumOfPath(n - 1) + getNumOfPath(n - 2) + getNumOfPath(n - 3);
}
```


> [!NOTE] getNumOfPath(0)이 1을 반환하는 이유?
> getNumOfPath(0)은 이미 완성된 경로이므로 1을 반환해야 전체 경우의 수 계산이 맞다.
> 만약 처음부터 n이 0으로 들어온다면 계단이 하나도 없는 상태에서 시작이라는 의미인데 이는 이미 아무것도 안 하고 도착해 있는 경우이기 때문에 1가지라고 보는 것이다.

근데 역시 재귀보다는 DP가 더 효율적이다.

```java
public static int getNumOfPath(int n) {
	if (n < 0) return 0;
	if (n == 0 || n == 1) return 1;
	if (n == 2) return 2;

	int[] dp = new int[n + 1];
	dp[0] = 1;
	dp[1] = 1;
	dp[2] = 2;

	for (int i = 3; i <= n; i++) {
		dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
	}

	return dp[n];
}

// 공간 최적화 ver
public static int getNumoFPathOptimized(int n) {
	if (n < 0) return 0;
	if (n == 0 || n == 1) return 1;
	if (n == 2) return 2;

	int a = 1;
	int b = 1;
	int c = 2;
	int result = 0;

	for (int i = 3; i <= n; i++) {
		result = a + b + c;
		a = b;
		b = c;
		c = result;
	}

	return result;
}
```

## 애너그램 생성(11.5)

"abcd"의 모든 애너그램을 구해 보자.
하향식으로 접근하면 "abcd"의 하위 문제는 "abc"일 것이다.
그렇다면 "abc"의 모든 애너그램을 반환하는 anagram 함수가 있을 때 이를 이용해 어떻게 "abcd"의 모든 애너그램을 만들어낼까?
각 애너그램에 "d"를 가능한 자리마다 삽입하면 된다.

```java
import java.util.List;
import java.util.List;

public static List<String> getAnagrams(String str) {

	List<String> result = new ArrayList<>();

	// base case
	if (str.length() == 1) {
		result.add(str);
		return result;
	}

	for (int i = 0; i < str.length(); i++) {
		char fixed = str.charAt(i);
		String remaining = str.substring(0, i) + str.substring(i + 1);

		List<String> subAnagrams = getAnagrams(remaining);

		for (String sub : subAnagrams) {
			result.add(fixed + sub);
		}
	}

	return result;
}
```


> [!NOTE] DP와 재귀의 차이점
> 
> DP는 작은 문제의 해를 저장해서 큰 문제에 활용하는 방식이다. 애너그램은 생성 결과가 `n!`개라서 저장할 게 너무 많다. n이 10만 되어도 결과가 3,628,800개.
> 
> DP는 "최적해" 혹은 "경로 개수"를 구할 때 효과적이다. "모든 순열을 나열"하는 데는 중복 계산을 줄일 구조가 없다. 결국 하나하나 다 만들어야 하므로 DP의 장점이 사라짐

이 애너그램 생성을 빅 오 관점에서 보면
O(n!)인데 이는 O(2<sup>n</sup>)보다도 크다. 이는 매우 느리지만 모든 애너그램을 생성해야 하는 상황에선느 더 나은 방법이 없다.

DP에 대해서는 다음 장에서 자세히 알아보자.
