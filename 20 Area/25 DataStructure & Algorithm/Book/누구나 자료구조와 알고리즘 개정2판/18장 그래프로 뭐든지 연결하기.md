SNS처럼 친구 관계를 맺는 서비스에서 친구 관계는 어떤 자료 구조에 저장할까?
만약 그냥 2차원 배열에 저장하면 한 명의 친구 관계를 알기 위해 모든 배열을 확인해야 하는 불필요함이 있다. 하지만 그래프를 사용하면 친구 관계를 O(1)만에 찾을 수 있다.

# 그래프(18.1)

![[graph.png]]

모든 트리는 그래프이지만, 그래프가 모두 트리는 아니다.
트리에는 사이클이 있을 수 없지만 그래프는 가능하다. 또한 트리는 모든 노드가 어떻게든 다른 노드와 연결되지만 그래프는 완전히 연결되지 않을 수도 있다.

각 노드는 정점(vertex), 점점을 잇는 선은 간선(edge)라 부른다. 간선으로 연결된 정점은 서로 인접한다(adjacent)고 한다. 모든 정점이 어떻게든 연결된 그래프를 연결 그래프(connected graph)라 부른다.

하지만 보통 팔로우 관계를 보면 방향성이 있다. 서로를 꼭 모두 팔로우 하지 않는다.
이와 같은 그래프를 방향 그래프(directed graph)라 한다.

## 객체 지향 그래프 구현(18.3)

자바는 그래프 자료구조는 따로 제공하지 않는다.
자바에서 복잡한 그래프 기능을 쓰고 싶으면 직접 구현보다는 라이브러리를 쓰는 게 일반적이다.
`JGraphT`, `Guava Graph` 등

`Map + List`로 직접 만들 수도 있다.

### 인접 리스트 vs 인접 행렬

```
인접 리스트(Adjacency List)

1 -> [2, 3]
2 -> [1, 4]
3 -> [1]
4 -> [2]
```

장점
- 공간 절약
- 이웃 탐색이 빠름
단점
- 두 정점이 연결됐는지 확인하는 데 시간이 걸릴 수 있음


```
인접 행렬(Adjacency Matrix)

   1 2 3 4
1 [0 1 1 0]
2 [1 0 0 1]
3 [1 0 0 0]
4 [0 1 0 0]
```

장점
- 두 정점이 연결됐는지 즉시 확인 가능
- 구현이 단순
단점
- 메모리 낭비(간선이 적을 때)
- 이웃 정점 탐색 시 불필요한 0까지 검사로 비효율적


결론적으로
정점 개수가 많고 간선이 적다 => 인접 리스트
정점 개수가 적거나 간선이 많다 => 인접 행렬

BFS/DFS -> 보통 인접 리스트가 더 효율적
Floyd-Warshall(모든 쌍 최단 경로) -> 인접 행렬이 적합

## 그래프 탐색(18.4)

![[graph-search.png]]

위 경우에서 Alice에서 Irena를 찾는 경로는 두 가지다.
여기서 경로는 한 정점에서 다른 정점으로 가는 간선들의 순열을 뜻한다.



### 깊이 우선 탐색(18.5)
DFS(Depth First Search)

트리와 달리 그래프는 사이클이 있을 수 있어 탐색 시 무한히 순회할 수 있음을 유의해야 한다.
이를 해결하는 방법 중 하나는 방문한 정점을 기록해두는 것이다.

방문한 노드를 해시 테이블에 추가하는 방법으로 해결할 수 있다.

1. 그래프 내 임의의 정점에서 시작
2. 현재 정점을 해시 테이블에 추가(방문)
3. 현재 정점의 인접 정점을 순회
4. 방문한 정점이면 무시
5. 방문하지 않았던 정점이면 그 정점에 대해 재귀적으로 깊이 우선 탐색을 수행

```java
// 양방향 그래프, 인접 리스트
import java.util.*;

public class GraphDFS {
	private Map<Integer, List<Integer>> adjList = new HashMap<>();
	
	// 정점 추가
	public void addVertex(int v) {
		adjList.putIfAbsent(v, new ArrayList<>());
	}
	
	// 간선 추가
	public void addEdge(int v1, int v2) {
		adjList.get(v1).add(v2);
		adjList.get(v2).add(v1);
	}
	
	// DFS 재귀
	public void dfsRecursive(int start, Set<Integer> visited) {
		visited.add(start);
		System.out.print(start + " ");
		
		for (int neighbor : adjList.get(start)) {
			if (!visited.contains(neighbor)) {
				dfsRecursive(neighbor, visited);
			}
		}
	}
	
	// DFS 스택
	public void dfsIterative(int start) {
		Set<Integer> visited = new HashSet<>();
		Stack<Integer> stack = new Stack<>();
		
		stack.push(start);
		while (!stack.isEmpty()) {
			int vertex = stack.pop();
			if (!visited.contains(vertex)) {
				visited.add(vertex);
				System.out.print(vertex + " ");
				for (int neighbor : adjList.get(vertex)) {
					if (!visited.contains(neighbor)) {
						stack.push(neighbor);
					}
				}
			}
		}
	}
}
```

#### 재귀
장점
- 코드가 직관적이고 짧다. 구현이 간단.
- 재귀 호출이 자연스럽게 스택 역할.
단점
- 재귀 호출 깊이가 제한됨(기본적으로 1~2만 단계에서 `StackOverflowError` 발생 가능)
#### 스택
장점
- 명시적으로 `Stack` 객체를 쓰기에 `StackOverFlowError` 위험이 없음
- 큰 그래프에서도 안정적으로 동작
- 탐색 과정을 제어하기에 더 유연
단점
- 코드가 재귀보다 더 길고 덜 직관적
- 스택 push/pop 로직 구현 필요

### 너비 우선 탐색(18.6)
BFS(Breadth First Search)

재귀를 사용하지 않고 큐를 사용.

1. 그래프 내 아무 정점에서 시작
2. 시작 정점을 해시 테이블에 추가(방문)
3. 시작 정점을 큐에 추가
4. 큐가 빌 때까지 루프 실행
5. 루프 안에서 큐의 첫 번째 정점 삭제.(현재 정점)
6. 현재 정점의 인접 정점을 순회
7. 이미 방문한 인접 정점 무시
8. 아직 방문하지 않은 정점이면 해시 테이블에 방문 표시 후 큐에 추가
9. 큐가 빌 때까지 루프 반복

```java
// 양방향 그래프, 인접 리스트
import java.util.*;

public class GraphBFS {
	private Map<Integer, List<Integer>> adjList = new HashMap<>();
	
	// 정점 추가
	public void addVertex(int v) {
		adjList.putIfAbsent(v, new ArrayList<>());
	}
	
	// 간선 추가
	public void addEdge(int v1, int v2) {
		adjList.get(v1).add(v2);
		adjList.get(v2).add(v1);
	}
	
	// BFS
	public void bfs(int start) {
		Set<Integer> visited = new HashSet<>();
		Queue<Integer> queue = new ArrayDeque<>();
		
		visited.add(start);
		queue.add(start);
		
		while (!queue.isEmpty()) {
			int vertex = queue.poll();
			System.out.print(vertex + " ");
			
			for (int neighbor : adjList.get(vertext)) {
				if (!visited.contains(neighbor)) {
					visited.add(neighbor);
					queue.add(neighbor);
				}
			}
		}
	}
}
```

### DFS vs BFS

BFS는 시작 정점과 가까운 정점을 모두 순회한 후 멀어진다.
DFS는 시작 정점과 즉시 멀어진 후 돌아온다.

상황에 맞게 선택하면 된다.

### 그래프 탐색의 효율성

정점의 수 뿐만 아니라 간선의 수도 중요하다.
V를 정점 수, E를 간선 수라 하면 그래프 탐색의 시간 복잡도는 O(V + E)로 표현한다.
정확한 것은 아니다. 실제 그래프 탐색에서는 각 간선을 두 번 이상 방문하기 때문이다.
빅 오 표현에서는 이 정도 근사치면 충분하다.



> [!NOTE] 그래프 데이터베이스
> 그래프는 SNS처럼 관계를 표현하는 데이터를 처리하는 데 매우 효율적이므로 실제 애플리케이션에서는 이러한 종류의 데이터를 특수한 그래프 데이터베이스로 저장하는 경우가 많다. 예로는 `Neo4j`, `ArangoDB`, `Apache Giraph` 등이 있다.

## 가중 그래프

그래프 간선에 정보를 추가하는 가중 그래프(weighted graph)이다.
예를 들어 각 도시 간 거리 정보를 표시할 때 사용하거나 방향 그래프를 사용하여 항공료 등을 계산할 수 있다.

### 최단 경로 문제

![[weighted graph.png]]

Atlanta -> El Paso의 경로 중 가장 비용이 적게 드는 경로를 찾는다고 할 때 알고리즘을 어떻게 구현할 수 있을까?

#### 다익스트라 알고리즘

1. 시작 정점 선택
	시작 정점의 가중치를 0, 나머지 정점들의 가중치를 최대값으로 초기화.
2. 아직 방문하지 않은 정점 중 가장 가중치가 낮은 정점 선택
	처음에는 시작 정점 선택
3. 선택된 정점의 모든 인접 정점에 대해 거리 값 갱신
	현재 정점을 거쳐서 가는 거리가 기존에 기록된 거리보다 짧다면 더 짧은 값으로 갱신
4. 해당 정점 방문 처리
5. 모든 정점 방문까지 반복

```java
import java.util.*;

class Edge {
	String to;
	int weight;
	
	public Edge(String to, int weight) {
		this.to = to;
		this.weight = weight;
	}
}

public class DijkstraGraph {
	private Map<String, List<Edge>> graph = new HashMap<>();
	
	// 정점 추가
	public void addVertex(String v) {
		graph.putIfAbsent(v, new ArrayList<>());
	}
	
	// 간선 추가
	public void addEdge(String from, String to, int weight) {
		graph.get(from).add(new Edge(t0, weight));
	}
	
	// 다익스트라
	public void dijkstra(String start, String end) {
		// start -> X의 현재까지 알려진 최소 비용
		Map<String, Integer> dist = new HashMap<>();
		// X로 오기 직전 정점
		Map<String, String> prev = new HashMap<>();
		// 아직 방문하지 않은 정점 중 가중치가 가장 적은 정점 선택을 위한 자료 구조
		PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));
		
		for (String v : graph.keySet()) {
			dist.put(v, Integer.MAX_VALUE);
		}
		dist.put(start, 0);
		pq.add(new Edge(start, 0)):
		
		while (!pq.isEmpty()) {
			Edge current = pq.poll();
			String curNode = current.to;
			
			if (current.weight > dist.get(curNode)) continue;
			
			for (Edge edge : graph.get(curNode)) {
				int newDist = dist.get(curNode) + edge.weight;
				if (newDist < dist.get(edge.to)) {
					dist.put(edge.to, newDist);
					prev.put(edge.to, curNode);
					pq.add(new Edge(edge.to, newDist));
				}
			}
		}
		
		if (dist.get(end) == Integer.MAX_VALUE) {
			System.out.println("경로 없음");
			return;
		}
		
		System.out.println("최단 비용: $" + dist.get(end));
		
		// 경로
		List<String> path = new ArrayList<>();
		for (String at = end; at != null; at = prev.get(at)) {
			path.add(at);
		}
		Collections.reverse(path);
		System.out.println("경로: " + String.join(" -> ", path)):
	}
	
	
	public static void main(String[] args) {
        DijkstraGraph graph = new DijkstraGraph();

        // 정점 추가
        for (String city : Arrays.asList("Boston", "Chicago", "Denver", "Atlanta", "El Paso")) {
            graph.addVertex(city);
        }

        // 간선 추가 (이미지 기준)
        graph.addEdge("Boston", "Chicago", 120);
        graph.addEdge("Boston", "Denver", 180);

        graph.addEdge("Chicago", "El Paso", 80);

        graph.addEdge("Denver", "El Paso", 140);
        graph.addEdge("Denver", "Chicago", 40);

        graph.addEdge("Atlanta", "Boston", 100);
        graph.addEdge("Atlanta", "Denver", 160);

        graph.addEdge("El Paso", "Boston", 100);

        // 다익스트라 실행
        graph.dijkstra("Atlanta", "El Paso");
    }
}

/*
0. 초기화
   dist: { Atlanta: 0, Chicago: ∞, Denver: ∞, El Paso: ∞, Boston: ∞ }
   pq: [ (Atlanta, 0) ]
   
1. 첫 번째 순회
   current: (Atlanta, 0)
   pq: []
   curNode: Atlanta
   
   current.weight: 0
   dist.get(curNode): 0
   
	for문
	edge: (Denver, ∞)
	   newDist: 0 + 160
	   dist.get(edge.to): ∞
	   
	   dist: { Atlanta: 0, Chicago: ∞, Denver: 160, El Paso: ∞, Boston: ∞ }
	   prev: { Denver: Atlanta }
	   pq: [ (Denver, 160) ]
	   
	edge: (Boston, ∞)
	   newDist: 0 + 100
	   dist.get(edge.to): ∞
	   
	   dist: { Atlanta: 0, Chicago: ∞, Denver: 160, El Paso: ∞, Boston: 100 }
	   prev: { Denver: Atlanta, Boston: Atalnta }
	   pq: [ (Boston, 100), (Denver, 160) ]
   
2. 두 번째 순회
   current = (Boston, 100)
   pq: [ (Denver, 160) ]
   curNode: Boston
   
   current.weight: 100
   dist.get(Boston): 100
   
   for문
   edge: (Chicago, 120)
	   newDist: 100 + 120
	   dist.get(edge.to): ∞
	   
	   dist: { Atlanta: 0, Chicago: 220, Denver: 160, El Paso: ∞, Boston: 100 }
	   prev: { Denver: Atlanta, Boston: Atalnta, Chicago: Boston }
	   pq: [ (Denver, 160), (Chicago, 220) ]
	   
   edge: (Denver, 180)
	   newDist = 100 + 180 = 280
	   dist.get(edge.to): 160
   
...

dist: { Atlanta: 0, Boston: 100, Chicago: 200, Denver: 160, El Paso: 280 }
prev: { Boston: Atlanta, Denver: Atlanta, Chicago: Denver, El Paso: Chicago }
pq: []
*/
```
