빅 오가 알고리즘을 결정하게 해주는 유일한 도구는 아니다.
한 알고리즘이 다른 알고리즘보다 훨씬 빠른 경우에도 두 알고리즘을 같은 방식으로 표현하기도 한다.

# 선택 정렬(5.1)

```java
for (int i = 0; i < arr.length - 1; i++) {
	int lowestNumIdx = i;
	for (int j = i + 1; j < arr.length; j++) {
		if (arr[j] < arr[lowestNumIdx]) lowestNumIdx = j;
	}

	if (lowestNumIdx != i) {
		int tmp = arr[i];
		arr[i] = arr[lowestNumIdx];
		arr[lowestNumIdx] = tmp;
	}
}
```

배열의 원소가 5개라면 비교는 4 + 3 + 2 + 1 = 10번이 일어난다.
일반화 하면 (N - 1) + (N - 2) + (N - 3) + ... + 1번이다. => `(N(N - 1))/2`

최악의 경우 교환의 수는 각 비교마다 교환이 일어나는 경우다.
즉 배열의 원소가 5라면 4번의 교환이 일어나는 것이다.
일반화 하면 (N - 1)번이다.

빅 오 표기법에서 중요한 건 차수다. 따라서 선택 정렬 또한 버블 정렬과 동일하게 시간 복잡도는 O(N<sup>2</sup>)이다.

하지만 실제 식을 살펴보자

| 정렬 방식 | 빅 오 표기           | 실제 식                      | 예시 값 80 |
| ----- | ---------------- | ------------------------- | ------- |
| 버블 정렬 | O(N<sup>2</sup>) | N<sup>2</sup> - N         | 6320    |
| 선택 정렬 | O(N<sup>2</sup>) | (N<sup>2</sup> + N - 2)/2 | 3239    |
표에서 비교한 바에 따르면 선택 정렬이 버블 정렬보다 단계가 반 정도 적다. 즉 두 배 더 빠르다.
하지만 빅 오 표기는 같다. 왜일까?

예를 들어 O(N<sup>2</sup>)과 O(N) 알고리즘을 비교할 때 두 효율성 간 차이가 너무 커서 O(N)이 실제로 O(2N)이든 O(100N)이든 별로 중요하지 않다.
이전 장에서 말했듯 중요한 건 성장률이다.
O(N)에 어떤 수를 곱하든 데이터가 커지다 보면 언젠가는 O(N<sup>2</sup>)이 더 느려진다.

빅 오 표기법은 전체적인 성능 등급을 비교할 때는 유용하지만 실제 성능 차이나 알고리즘의 특성을 판단하는 데는 한계가 있다.
늘 최악의 경우만 일어나는 것이 아니므로 최선/평균/최악 등을 함께 고려해야 진짜 효율적인 알고리즘을 선택할 수 있다.



