# 삽입 정렬(6.1)

```java
for (int i = 1; i < arr.length; i++) {
	int tmp = arr[i];
	int position = i - 1;

	while (position >= 0) {
		if (arr[position] > tmp) {
			arr[position + 1] = arr[position];
			position -= 1;
		} else {
			break;
		}
	}

	arr[position + 1] = tmp;
}
```

삽입 정렬의 단계는 보관, 비교, 이동, 삽입 네 종류다.

최악의 비교는 1 + 2 + 3 + ... + (N - 1)번이다. => (N(N - 1))/2
최악의 이동은 비교할 때마다 이동하는 것이므로 동일하게 1 + 2 + 3 + ... + (N - 1)번이다.
보관은 항상 (N - 1)번이고
삽입도 항상 (N - 1)번이다.

모두 더하면 N<sup>2</sup> + N - 2 단계다.

| 정렬 방식 | 빅 오 표기           | 실제 식(최악의 경우)              | 예시 값 80 |
| ----- | ---------------- | ------------------------- | ------- |
| 버블 정렬 | O(N<sup>2</sup>) | N<sup>2</sup> - N         | 6320    |
| 선택 정렬 | O(N<sup>2</sup>) | (N<sup>2</sup> + N - 2)/2 | 3239    |
| 삽입 정렬 | O(N<sup>2</sup>) | N<sup>2</sup> + N - 2     | 6478    |
위 표를 보면 선택 정렬이 가장 좋은 알고리즘이라 생각할 수 있다.

![[시나리오 그래프.png]]

최선, 최악의 시나리오는 상대적으로 드물게 발생하고 대부분 평균 시나리오가 일어난다.

이제 모든 시나리오 관점에서 정렬을 검토해 보자.

| 구분    | 최선의 시나리오          | 평균 시나리오           | 최악의 시나리오          |
| ----- | ----------------- | ----------------- | ----------------- |
| 선택 정렬 | N<sup>2</sup> / 2 | N<sup>2</sup> / 2 | N<sup>2</sup> / 2 |
| 삽입 정렬 | N                 | N<sup>2</sup> / 2 | N<sup>2</sup>     |
가장 많이 발생하는 평균 시나리오의 경우 단계가 같은 것을 볼 수 있다.

최선, 평균, 최악의 시나리오를 구분하는 능력은 기존 알고리즘을 최적화해서 훨씬 빠르게 만드는 것만큼이나 사용자 요구에 맞는 최적의 알고리즘을 고르는 핵심 기술이다. 최악을 대비하는 것도 좋지만 대부분 평균적인 경우가 일어난다는 점을 명심하자.


