# 버블정렬(4.1)
```java
boolean sorted = false;
int lastIdx = arr.length - 1;

while (!sorted) {
	sorted = true;
	for (int i = 0; i < lastIdx; i++) {
		if (arr[i] > arr[i + 1]) {
			int tmp = arr[i];
			arr[i] = arr[i + 1];
			arr[i + 1] = tmp;

			sorted = false;
		}
	}
	lastIdx -= 1;
}
```

버블 정렬은 두 가지 단계가 있다.
- 비교
- 교환

배열의 원소가 5개라면 비교는 4 + 3 + 2 + 1 = 10번이 일어난다.
일반화 하면 (N - 1) + (N - 2) + (N - 3) + ... + 1번이다. => `(N(N - 1))/2`

최악의 경우 교환의 수는 모든 비교에서 교환이 일어나는 것이므로 비교와 동일하다.

```
보통 시간 복잡도 분석 시 비교가 주된 기준이 된다. 교환은 보조적 기준이라 한다.
```

빅 오 표기법은 상한선을 의미하며 입력 크기 N이 커질수록 어떤 함수가 얼마나 빠르게 증가하는지를 본다.
여기서 중요한 건 성장률 즉 차수다.

따라서 버블 정렬의 시간 복잡도는 O(N<sup>2</sup>)이다. 이를 이차 시간이라고도 부른다

# 이차 분제(4.4)

보통 O(N<sup>2</sup>)은 상대적으로 느린 알고리즘으로 간주되기에 이를 마주할 시 더 빠른 대안은 없을지 깊이 생각해 보는 것이 좋다.

느린 O(N<sup>2</sup>)을 빠른 O(N)으로 대체할 수 있는 현실적인 예제를 보자.

- 1에서 10 사이의 숫자 중 중복 숫자가 있는지 확인하는 함수
```java
public class DuplicateChecker {

    public static boolean hasDuplicate(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                if (i != j && arr[i] == arr[j]) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

위 함수는 O(N<sup>2</sup>) 시간 복잡도를 갖는다.
이를 해결해 보자.

```java
public class DuplicateChecker {

    public static boolean hasDuplicate(int[] arr) {
        int[] counts = new int[10];

		for (int i = 0; i < arr.length; i++) {
			int idx = arr[i] - 1;
			if (counts[idx] != 0) {
				return true;
			} else {
				counts[idx]++;
			}
		}
		return false;
    }
}
```

이렇게 O(N)으로 최적화할 수 있다.

빅 오 표기법에서는 두 알고리즘의 속도가 같다고 해도 실제로는 어느 한 쪽이 더 빠른 상황이 벌어지는데 이는 5장에서 자세히 다룬다.