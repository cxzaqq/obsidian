# 1.1 HTTP: 인터넷의 멀티미디어 배달부

HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용하기에 데이터가 지구 반대편에서 오더라도 전송 중 손상되거나 꼬이지 않음을 보장한다.

개발자는 인터넷의 결함이나 약점에 대한 걱정 없이 애플리케이션 고유의 기능을 구현하는 데 집중할 수 있다.

# 1.2 웹 클라이언트와 서버

클라이언트는 서버에게 HTTP 요청을 보내고 서버는 요청된 데이터를 HTTP 응답으로 돌려준다.

# 1.3 리소스

웹 서버는 웹 리소스를 관리하고 제공한다.

가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 파일이다.

정적 파일: 텍스트 파일, HTML 파일, 마이크로소프트 워드 파일, 어도비 아크로뱃 파일, HPEG 이미지 파일, AVI 동영상 파일, 그 외 모든 종류의 파일을 포함

리소스는 반드시 정적 파일이어야 할 필요는 없다.

동적 리소스: 라이브 영상, 주식 거래, 부동산 DB 검색 등

## 1.3.1 미디어 타입

인터넷은 수천 가지 데이터 타입을 다루기 때문에 객체 각각에 신중하게 MIME(Multipurpose Internet Mail Extensions) 타입이라는 데이터 포맷 라벨을 붙인다.

MIME은 원래 각기 다른 전자메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계되었다. 이메일에서 잘 동작했기에 HTTP에서도 멀티미디어 컨텐츠 기술하고 라벨을 붙이기 위해 채택되었다.


웹브라우 저는 서버로부터 객체를 돌려받을 때, 다룰 수 있는 객체인지 MIME 타입을 통해 확 인한다.

대표 예
HTML 문서: text/html
plain ASCII 텍스트 문서: text/plain
JPEG: image/jpeg
GIF: image/gif
ppt: application/vnd.ms-powerpoint

## 1.3.2 URI

Uniform Resource Identifier
Uniform: 리소스를 식별하는 통일된 방식
Resource: URI로 식별이 가능한 모든 종류의 자원
Identifier: 다른 항목과 구분하기 위해 필요한 정보
정보 리소스를 고유하게 식별하고 위치 지정 가능

- URL(Uniform Resource Locator) 특정 서버의 한 리소스에 대한 구체적인 위치를 서술
	ex) `http://www.yahoo.com/images/logo.gif`
	scheme: `http://`
	서버의 인터넷 주소: `www.yahoo.com`
	웹 서버의 리소스: `/images/logo.gif`
	대부분의 URI는 URL이다.

- URN(Uniform Resource Name)
	컨텐츠를 이루는 한 리소스에 대해 그 리소스의 위치에 영향을 받지 않는 유일무이한 이름(위치 독립적), 리소스의 이름이 변하지 않는 한, 리소스를 다른 위치로 옮기더라도 문제 없이 동작

![[URI.png]]

# 1.4 트랜잭션

클라이언트 -> 서버: 요청 명령
서버 -> 클라이언트: 응답 결과

## 1.4.1 메서드

HTTP 요청 메시지는 한 개의 메서드를 갖는다. 이 메서드는 서버에게 어떤 동작이 취해져야 하는지 말해준다.

대표
- GET: 서버에서 클라이언트로 지정한 리소스를 보내라.
- PUT: 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라
- DELETE: 지정한 리소스를 서버에서 삭제하라
- POST: 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라
- HEAD: 지정한 리소스에 대한 응답에서 HTTP 헤더 부분만 보내라
3장에서 자세히

## 1.4.2 상태 코드

대표
- 200: 문서가 바르게 반환됨
- 302: 다시 보내라
- 404: 리소스 없음
3장에서 자세히

## 1.4.3 웹 페이지는 여러 객체로 이뤄질 수 있다.

애플리케이션은 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행한다.

# 1.5 메시지

HTTP 메시지는 단순한 줄 단위의 문자열이다. 이진 형식이 아닌 일반 텍스트이기에 사람이 읽고 쓰기 쉽다.

예시

|     | 요청 메시지                                                                                                                                                        | 응답 메시지                                                                                                                                                                                                    |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 시작줄 | `GET /tools.html HTТР/1.0`                                                                                                                                    | `HTTP/1.0 200 OK`                                                                                                                                                                                         |
| 헤더  | `User-agent: Mozilla/4.75 [en] (Win98; U)`<br>`Host: www.joes-hardware.com`<br>`Accept: text/html, image/gif, image/jpeg`<br>`Accept-language: en`<br>` `<br> | `Date: Sun, ol Oct 2000 23:25:17 GMT`<br>`Server: Apache/1.3.11 BSafe-SSL/1.38 (Unix)`<br>`Last-modified: Tue, 04 Jul 2000 09:46:21 GMT`<br>`Content-length: 403`<br>`Content-type: text/html`<br>` `<br> |
| 본문  |                                                                                                                                                               | `<HTML> ... `                                                                                                                                                                                             |

시작줄: 요청 시 무엇을 해야 하는지, 응답 시 무슨 일이 일어났는지 나타냄
헤더: 0개 이상의 헤더 필드가 이어진다. 헤더는 빈 줄로 끝난다.
본문: 빈 줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 온다.

## 1.6 TCP 커넥션

Transmission Control Protocol

## 1.6.1 TCP/IP

HTTP는 애플리케이션 계층 프로토콜. HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경쓰지 않는다. 대신 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에 맡긴다.

TCP는 다음을 보장한다
- 오류 없는 데이터 전송
- 순서에 맞는 전달(데이터는 어제나 보낸 순서대로 도착)
- 조각나지 않은 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다)

인터넷 자체가 전 세계의 컴퓨터와 네트워크 장치들 사이에서 대중적으로 사용되는 TCP/IP에 기초하고 있다. TCP/IP는 TCP와 IP가 층을 이루는 패킷 교환 네트워크 프로토콜의 집합이다.

TCP/IP는 각 네트워크와 하드웨어의 특성을 숨기고 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해준다.

일단 TCP 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나 손상되거나 순서가 뒤바뀌어 수신되는 일은 결코 없다.

네트워크 개념상 HTTP 프로토콜은 TCP 위의 계층이다. HTTP는 자신의 메시지 데이터를 전송하기 위해 TCP를 사용한다. 이와 유사하게 TCP는 IP위의 계층이다.

| HTTP 네트워크 프로토콜 스택 | 계층        |
| ----------------- | --------- |
| HTTP              | 애플리케이션 계층 |
| TCP               | 전송 계층     |
| IP                | 네트워크 계층   |
| 네트워크를 위한 링크 인터페이스 | 데이터링크 계층  |
| 물리적인 네트워크 하드웨어    | 물리 계층     |

## 1.6.2 접속, IP 주소 그리고 포트 번호

HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에 인터넷 프로토콜(Internet Protocol, IP) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 한다.

HTTP 서버의 IP 주소와 포트 번호는 어떻게 알아낼 수 있을까? => URL

`http://207.200.83.29:80/index.html`
IP: `207.200.83.29`
PORT: `80`
DNS => `http://www.netscape.com/index.html`
(포트는 생략 시 기본 80)

1. 웹브라우저는 서버의 URL에서 호스트 명 추출
2. 서버의 호스트 명을 IP로 변환
3. URL에서 포트번호(있다면) 추출
4. 웹 서버와 TCP 커넥션
5. 서버에 HTTP 요청
6. 서버는 웹브라우저에 HTTP 응답
7. 커넥션이 닫히면 웹브라우저는 리소스를 보여줌

## 1.6.3 텔넷을 이용한 실제 예제

HTTP는 TCP/IP를 사용하며 이진 형식이 아닌 문자열 기반이기에 웹 서버와 직접 대화하는 것도 간단하다.


> [!NOTE] Telnet?
> TCP/IP 기반 프로토콜. 인터넷을 통해 원격지에 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 원격 터미널을 사용할 수 있도록 해주는 서비스. 암호화X

```linux
% telnet www.joes-hardware.com 80
Trying 128.121.66.211...
Connected to joes-hardware.com.
Escape character is '^]'.
GET /tools.html HTTP/1.1
Host: www.joes-hardware.com

HTTP/1.1 200 OK Date: Mon, 18 Nov 2013 11:36:48 GMT
Server: Apache/2.2.22 (Unix) DAV/2 FrontPage/5.0.2.2635 mod_ssl/2.2.22 OpenSSL/1.0.1c Last-Modified: Fri, 12 Jul 2002 07:50:17 GMT
ETag: "146deb7-1b1-3a58f649c4040"
Accept-Ranges: bytes
Content-Length: 433
Content-Type: text/html 

<HTML>
<HEAD><TITLE>Joe's Tools</TITLE></HEAD>
...
```

# 1.7 프로토콜 버전

- HTTP/0.9
1991년의 HTTP 프로토타입. 심각한 디자인 결함, 구식 클라이언트만 사용 가능, GET만 지원
MIME/HTTP 헤더/버전 번호 지원 X.
간단한 HTML 객체를 받아오기 위해 만들어진 것. 금방 HTTP/1.0으로 대체됨

- HTTP/1.0
처음으로 널리 쓰이기 시작한 버전.
버전 번호/HTTP 헤더/추가 메서드, 멀티미디어 객체 처리 추가
잘 정의된 명세서는 아님. 상업적, 학술적으로 급성장하던 시기에 만들어진 잘 동작하는 용례들의 모음에 가까움

- HTTP/1.0+
1990 중반 world wide web이 급격히 팽창, 상업적으로도 성공 -> 여러 유명 웹 클라이언트와 서버들은 그에 따른 요구를 만족하기 위해 HTTP에 기능 추가.
오래 지속되는 "keep-alive" 커넥션, 가상 호스팅 지원, 프락시 연결 지원을 포함 많은 기능이 공식적이진 않지만 사실상의 표준으로 HTTP에 추가. 이 규격 외의 확장된 HTTP 버전을 흔히 HTTP/1.0+라 부름

- HTTP/1.1
현재의 HTTP 버전
HTTP 설계의 구조적 결함 교정, 성능 최적화, 잘못된 기능 제거.
더 복잡해진 웹 애플리케이션과 배포를 지원.

- HTTP/2.0
HTTP/1.1 성능 문제 개선을 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행 중인 프로토콜.

![[HTTP2.png]]
10장에서 자세히

# 1.8 웹의 구성 요소

- 프락시
	클라이언트와 서버 사이에 위치한 HTTP 중개자
	
- 캐시
	많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
	
- 게이트웨이
	다른 애플리케이션과 연결된 특별한 웹 서버
	
- 터널
	단순히 HTTP 통신을 전달하기만 하는 특별한 프락시

- 에이전트
	자동회된 HTTP 요청을 만드는 준지능적(semi-intelligent) 웹클라이언트

## 1.8.1 프락시

프락시는 클라이언트와 서버 사이에 위치. 클라이언트의 모든 HTTP 요청을 받아 서버에 전달.
주로 보안을 위해 사용됨. 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할.
요청과 응답을 필터링.
6장에서 자세히

## 1.8.2 캐시

자주 찾는 것의 사본을 저장해 두는 특별한 종류의 HTTP 프락시 서버.
클라이언트가 같은 문서 요청 시 사본을 받는다.
웹 서버보다 가까이 위치 -> 훨씬 더 빨리 응답 받음
7장에서 자세히

## 1.8.3 게이트웨이

다른 서버들의 중개자로 동작하는 특별한 서버.
주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용.
스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룸.
8장에서 자세히

## 1.8.4 터널

두 커넥션 사이에 raw 데이터를 열어보지 않고 그대로 전달하는 HTTP 애플리케이션.
HTTP가 아닌 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송하기 위해 사용

예시로는 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송하여 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이 있다.
8장에서 자세히

## 1.8.5 에이전트

사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램.
웹 요청을 만드는 애플리케이션은 모두 HTTP 에이전트다.
대표적인 것이 웹브라우저. 다른 것들도 있다.
예를 들어 사람의 통제 없이 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키고 컨텐츠를 받아오는 자동화된 사용자 에이전트가 있다. '스파이더', '웹로봇' 등
9장에서 자세히
