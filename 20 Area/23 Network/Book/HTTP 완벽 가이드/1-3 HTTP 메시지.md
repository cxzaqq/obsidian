# 3.1 메시지의 흐름

HTTP 메시지 = HTTP 애플리케이션 간 주고받은 데이터의 블록들

## 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것.
모든 처리가 끝난 후 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것.

## 3.1.2 다운스트림으로 흐르는 메시지

요청이든 응답이든 메시지는 모두 다운스트림으로 흐른다.
메시지의 발송자는 수신자의 업스트림
(송신: 업스트림, 수신: 다운스트림)

# 3.2 메시지의 각 부분

시작줄, 헤더, 본문으로 나뉜다.

| 구분  | 예시                                             |
| --- | ---------------------------------------------- |
| 시작줄 | HTTP/1.0 200 OK                                |
| 헤더  | Content-type: text/plain<br>Content-length: 19 |
| 본문  | Hi! I'm a message!                             |

시작줄: 어떤 메시지인가?
헤더: 속성
본문(선택): 데이터

시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열.
각 줄은 CRLF를 통해 구분

> [!NOTE] CRLF
> CR: Carriage Return
> 커서가 맨 앞으로 이동(\r)
> 
> LF: Line Feed
> 줄을 바꿈(\n)

오래되거나 잘못 만들어진 HTTP 애플리케이션들 중에 CRLF를 모두 전송하지 않는 것들도 있기에 LF만 와도 처리할 수 있어야 한다.

## 3.2.1 메시지 문법

모든 HTTP 메시지는 요청 혹은 응답 메시지다.

### 요청 메시지 형식

<메서드> <요청URL> <버전>
<헤더>
	
<엔티티 본문>

ex)
`GET /specials/saw-blade.gif HTTP/1.0`
`Host: www.joes-hardware.com`

### 응답 메시지 형식

<버전> <상태코드> <사유구절>
<헤더>
	
<엔티티 본문>

ex)
`HTTP/1.0 200 OK`
`Content-Type: image/gif`
`Content-Length: 8572`


- 메서드
  클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작

- 요청 URL
  완전한 URL 혹은 URL의 경로 구성 요소.

- 버전
  HTTP/<메이저>.<마이너>
	메이저와 마이너는 모두 정수.

- 상태 코드
	요청 중 무엇이 일어났는지 설명하는 세 자리 숫자.

- 사유 구절
  상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구

- 헤더들
  이름, 콜론(:), 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들.
  빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔티티 본문의 시작을 표시.
	HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함되어야만 유효한 것으로 간주.

- 엔티티 본문
	모든 메시지가 엔티티 본문을 갖는 것은 아님. (15장에서 자세히)
	헤더나 엔티티 본문이 없더라도 HTTP 헤더의 집합은 반드시 CRLF로 끝나야 한다.


## 3.2.2 시작줄

- 요청
	메서드, 대상 URL, HTTP 버전
	공백으로 구분

- 응답
  HTTP 버전, 상태 코드, 사유 구절
  공백으로 구분

### 메서드

| 메서드     | 설명                           |
| ------- | ---------------------------- |
| GET     | 서버에서 리소스를 가져온다               |
| HEAD    | 서버에 리소스의 헤더만 가져온다            |
| POST    | 서버가 처리해야 할 데이터를 보낸다          |
| PUT     | 서버에 요청 메시지 본문을 저장            |
| TRACE   | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적 |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인     |
| DELETE  | 서버에서 문서를 제거                  |
HTTP는 쉽게 확장할 수 있도록 설계되었기에 다른 서버는 그들만의 메서드를 추가로 구현했을 수도 있다.

### 상태 코드

| 전체 범위     | 정의된 범위    | 분류       |
| --------- | --------- | -------- |
| 100 - 199 | 100 - 101 | 정보       |
| 200 - 299 | 200 - 206 | 성공       |
| 300 - 399 | 300 - 305 | 리다이렉션    |
| 400 - 499 | 400 - 415 | 클라이언트 에러 |
| 500 - 599 | 500 - 505 | 서버 에러    |

적은 수의 코드만을 정의했다.
프로토콜이 진화하면서, 더 많은 상태코드가 HTTP 명세에 공식적으로 정의될 것이다.
누군가 현재 프로토콜의 확장으로 다른 코드를 정의했을 가능성이 있다. 그럴 땐 분류를 보고 예측할 수 있다.

### 사유 구절

상태 코드에 대한 글로 된 설명을 제공.
규칙이 따로 없음.

### 버전 번호

HTTP/x.y 형식. 요청, 응답 모두에 기술. 자신이 따르는 프로토콜의 버전을 상대에게 말해주기 위한 수단.

HTTP/2.22는 HTTP/2.3보다 크다. 무조건 정수

## 3.2.3 헤더

이름/값 쌍의 목록

- 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더: 요청에 대한 부가 정보를 제공
- 응답 헤더: 응답에 대한 부가 정보를 제공
- 엔티티 헤더: 본문 크기와 컨텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더: 명세에 정의되지 않은 새로운 헤더

`<이름>:<공백(선택)><필드 값><CRLF>`

ex)
`Date: Tue, 3 Oct 1998 02:14:03 GMT`
`Accept: image/gif, image/jpeg, text/html`

긴 헤더는 여러 줄로 더 읽기 좋게 만들 수 있는데 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 함.

ex)
`HTTP/1.0 200 OK`
`Content-Type: image/gif`
`Content-Length: 8572`
`Server: Test Server`
	`Version 1.0`

=> `Server: Test Server Version 1.0`

## 3.2.5 버전 0.9 메시지

0.9는 HTTP 초기 버전이다. 훨씬 단순하다.
요청, 응답은 동일하지만 요청은 그저 메서드와 요청 URL만 있고 응답은 오직 엔티티로만 되어 있다.
=> 단순하기에 다양한 상황에서 대응할 수 없다.



# 3.3 메서드

모든 서버가 모든 메서드를 구현하지 않는다.

## 3.3.1 안전한 메서드

GET, HEAD는 안전하다고 말하는데 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
작용이 없다 => HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다.

안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다.(개발자에게 달림)
안전한 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.

## 3.3.2 GET

가장 흔히 쓰이는 메서드. 주로 서버에게 리소스를 달라고 요청하기 위해 쓰임.

## 3.3.3 HEAD

GET처럼 행동하지만 서버는 응답으로 헤더만을 돌려준다.
클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만 조사할 수 있도록 해준다.

서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다. 또한 HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다.

## 3.3.4 PUT

서버에 문서를 쓴다.
요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나 이미 존재 시 교체하는 것.

### 3.3.5 POST

서버에 입력 데이터를 전송하기 위해 설계.

### 3.3.6 TRACE

클라이언트가 어떤 요청을 할 때 그 요청은 방화벽, 프락시, 게이트웨이 드으이 애플리케이션을 통과할 수 있는데 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.
TRACE는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이는지 알려준다.

목적지 서버에서 loopback 진단을 시작. 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답 돌려줌.

클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지 알 수 있다.

이는 주로 진단을 위해 사용됨. 

## 3.3.7 OPTIONS

웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봄.

ex)
요청
`OPTIONS * HTTP/1.1`
`Host: www.joes-hardware.com`
`Accept: *`
응답
`HTTP/1.1 200 OK`
`Allow: GET, POST, PUT, OPTIONS`
`Context-length: 0`

## 3.3.8 DELETE

리소스 삭제 요청
클라이언트는 삭제가 수행되는 것을 보장하지 못한다. HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용함.

## 3.3.9 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계됨.
새로 기능을 추가해도 과거에 구현된 SW들의 오동작을 유발하지 않음.

ex)

| 메서드   | 설명                   |
| ----- | -------------------- |
| LOCK  | 사용자가 리소스를 잠글 수 있게 해줌 |
| MKCOL | 사용자가 문서를 생성할 수 있게 해줌 |
| COPY  | 서버에 있는 리소스 복사        |
| MOVE  | 서버에 있는 리소스 이동        |

개발자가 어떤 확장 메서드를 정의한다면 그것은 대부분의 HTTP 애플리케이션이 이해할 수 없다.
마찬가지로 나의 애플리케이션이 이해할 수 없는 확장 메서드를 사용하는 애플리케이션과 마주할 수도 있다.
이런 상황에서는 관용적인 것이 최고다. 프락시는 종단 간 행위를 망가뜨리지 않을 수 있다면 알려지지 않은 메서드가 담긴 메시지를 다운스트림 서버로 전달하려고 시도한다. 그렇지 않으면 프락시는 501 Not Implemented 상태 코드로 응답해야 한다.
"엄격하게 보내고 관대하게 받아들여라"

# 3.4 상태 코드

## 3.4.1 100-199: 정보성 상태 코드

HTTP/1.1에서 도입.
복잡함을 감수할 만한 가치가 있는지 논란

| 상태 코드 | 사유 구절               | 의미                                                                                 |
| ----- | ------------------- | ---------------------------------------------------------------------------------- |
| 100   | Continue            | 요청의 시작 부분 일부가 받아들여짐. 클라이언트는 나머지를 계속 이어서 보내야 함을 의미. 이것을 보낸 후 서버는 반드시 요청을 받아 응답해야 함. |
| 101   | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미                                  |
상태 코드 100은 HTTP 클라이언트 애플리케이션이 서버에 엔티티 본문을 전송하기 전에 그 엔티티 본문을 서버가 받아들일 것인지 확인하려고 할 때 그 확인 작업을 최적화하기 위한 의도로 도입.

클라이언트 애플리케이션은 100 continue를 서버가 다루거나 사용할 수 없는 큰 엔티티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다.
클라이언트는 서버가 100 continue 응답을 보내주기를 막연히 기다리는 것이 아니라 약간의 타임아웃 후에 그냥 엔티티를 보내야 한다.
클라이언트 개발자는 예상치 못한 100 응답에도 대비해야 한다. 몇몇 잘못 만들어진 HTTP 애플리케이션은 이 코드를 부적절하게 보낸다.

서버가 100 continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면 100 혹은 에러 코드로 답해야 한다. 서버는 절대로 100 응답을 받을 것을 의도하지 않은 클라이언트에게 100 상태 코드를 보내선 안 된다.
서버가 100 응답을 보내기 전에 엔티티의 일부(혹은 전체)를 수신했다면 서버는 이 상태 코드를 보낼 필요가 없다. => 클라이언트가 이미 전송하기로 결정했기 때문 => 이후 최종 응답(100은 안 보내도 됨)
만약 서버가 100 응답을 받을 것을 의도한 요청을 받고 엔티티의 본문을 읽기 전에 요청을 끝내기로 결정했다면(에러 등의 이유로) 서버는 그냥 응답을 보내고 연결을 닫으면 안 된다. 클라이언트가 응답 받을 수 없기에

프락시가 클라이언트로부터 100 응답을 의도한 요청을 받았다면 해야 할 일이 있다.
next-hop 서버(6장에서 자세히)가 HTTP/1.1을 따르거나 혹은 어떤 버전을 따르는지 모른다면 Expect 헤더를 포함시켜서 요청을 다음으로 전달해야 함.
HTTP/1.1보다 이전 버전의 HTTP를 따른다면 417 Expectation Failed 에러로 응답해야 함.
프락시가 HTTP/1.0이나 이전 버전을 따르는 클라이언트를 대신하여 Expect 헤더와 100 값을 요청에 포함하기로 결정했다면 프락시는 100 응답을 클라이언트로 전달하면 안 된다.
클라이언트는 그것을 어떻게 해야 할지 모르기에

## 3.4.2 200-299: 성공 상태 코드

| 상태 코드 | 사유 구절                         | 의미                                                                                                                            |
| ----- | ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| 200   | OK                            | 요청은 정상. 엔티티 본문은 요청된 리소스를 포함                                                                                                   |
| 201   | Created                       | 서버 개체를 생성하라는 요청을 위한 것.<br>서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 함                                                                   |
| 202   | Accepted                      | 요청은 받았지만 서버가 아직 어떤 동작도 수행하지 않았다.<br>서버는 엔티티 본문에 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료될 것인지에 대한 추정(혹은 그에 대한 정보를 어디서 얻을 수 있는지)도 포함해야 함 |
| 203   | Non-Authoritative Information | 엔티티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다.<br>필수는 아니다.                                                                          |
| 204   | No Content                    | 응답 메시지는 헤더와 상태줄을 포함하지만 엔티티 본문은 포함하지 않는다. 주로 웹 브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용.                                              |
| 205   | Reset Content                 | 주로 브라우저를 위해 사용되는 또 하나의 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 함.                                                        |
| 206   | Partial Content               | 부분 혹은 범위 요청이 성공.<br>Range Header(15장에서 자세히)<br>Content-Range와 Date 헤더를 반드시 포함해야 함.<br>Etag, Content-Location 중 하나도 반드시 포함해야 함 |

## 3.4.3 300-399: 리다이렉션 상태 코드

리소스가 옮겨졌다면 어디서 찾을 수 있는지 알려주기 위함.

몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용
ex)
`GET /seasonal/index-fall.html HTTP/1.1`
`Host: www.joes-hardware.com`
`Accept: *`
`If-Modified-Since: Fri, Oct 3 1997 02:16:00 GMT`

=> 해당 날짜 이후에 수정된 경우에만 문서를 가져와라.

`HTTP/1.1 304 Not Modified`

=> 원본에 변경이 없다면 브라우저는 로컬 복사본을 보여준다.

| 상태 코드 | 사유 구절              | 의미                                                                                                                                              |
| ----- | ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 300   | Multiple Choices   | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우 그 리소스의 목록과 함께 반환. 사용자는 목록에서 원하는 하나를 선택 가능.<br>ex) 하나의 HTML 문서를 영어와 프랑스어 모두로 제공하는 경우 등에 사용 가능.               |
| 301   | Moved Permanently  | 요청한 URL이 옮겨졌을 때 사용. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 함.                                                                               |
| 302   | Found              | 301과 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 함.                                                                         |
| 303   | See Other          | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 알림.<br>새 URL은 응답 메시지의 Location 헤더에 존재.<br>주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것                         |
| 304   | Not Modified       | 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 요청한 리소스가 취근에 수정된 일이 없다면 이 코드는 리소스가 수정되지 않았음을 의미하게 됨. 이 코드의 응답은 엔티티 본문을 가져서는 안 됨 |
| 305   | Use Proxy          | 리소스가 반드시 프락시를 통해 접근되어야 함을 나타내기 위해 사용. 프락시의 위치는 Location 헤더를 통해 주어짐. 클라이언트는 이 응답을 특정 리소스에 대한 것이라고만 생각.                                           |
| 307   | Temporary Redirect | 301과 유사. 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 함. 이후의 요청에서는 원래 URL 사용                                                         |
HTTP/1.0에서 클라이언트가 POST 요청 후 302 코드가 담긴 응답을 받으면 클라이언트는 Location 헤더에 들어있는 리다이렉트 URL을 GET 요청으로 따라갈 것이다.

그런데 HTTP/1.1은 그러한 리다이렉션을 위해 303 상태 코드를 사용한다.

이 혼란을 막기 위해 HTTP/1.1 명세는 HTTP/1.1 클라이언트의 일시적인 리다이렉트를 위해 302 대신 307을 사용하라고 한다. => 서버는 302 상태 코드를 HTTP/1.0 클라이언트에게 사용하기 위해 남겨둘 수 있을 것이다.

결국 서버는 적절한 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있다.

## 3.4.4 400-499: 클라이언트 에러 상태 코드

| 상태 코드 | 사유 구절                            | 의미                                                                                                                    |
| ----- | -------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| 400   | Bad Request                      | 잘못된 요청                                                                                                                |
| 401   | Unauthorized                     | 리소스를 얻기 전 인증 요구                                                                                                       |
| 402   | Payment Required                 | 현재 쓰이진 않음.                                                                                                            |
| 403   | Forbidden                        | 요청이 서버에 의해 거부되었음. 보통 거절의 이유를 숨기고 싶을 때 사용                                                                              |
| 404   | Not Found                        | 리소스 없음                                                                                                                |
| 405   | Method Not Allowed               | 지원하지 않은 메서드로 요청받았을 때 사용.<br>Allow 헤더 포함 필요                                                                            |
| 406   | Not Acceptable                   | 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없을 경우 사용.<br>클라이언트는 자신이 어떤 종류의 엔티티를 받아들이고자 하는지에 대해 매개변수로 명시 가능. <br>(17장에서 자세히) |
| 407   | Proxy Authentication Required    | 401과 유사. 리소스에 대한 인증을 요구하는 프락시 서버를 위해 사용                                                                               |
| 408   | Request Timeout                  | 요청 처리를 위한 시간이 너무 많이 걸리는 경우 서버는 이 상태 코드로 응답 후 연결을 끊을 수 있다.<br>타임아웃의 길이는 서버마다 다르지만 대개 충분히 길다.                           |
| 409   | Conflict                         | 요청이 충돌을 일으킬 염려가 있다고 생각될 때 사용.<br>충돌에 대한 설명 본문 포함 필요                                                                   |
| 410   | Gone                             | 404와 유사. 서버가 한때 그 리소스를 갖고 있었다는 것.                                                                                     |
| 411   | Length Required                  | 서버가 요청 메시지에 Content-Lnegth 헤더가 있을 것을 요구할 때 사용.                                                                        |
| 412   | Precondition Failed              | 클라이언트가 조건부 요청을 했는데 그 중 하나가 실패했을 때 사용.                                                                                 |
| 413   | Request Entity Too Large         | 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 때 사용                                                               |
| 414   | Request URI Too Long             | 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을 때 사용.                                                  |
| 415   | Unsupported Media Type           | 서버가 이해하거나 지원하지 못하는 내용 유형의 엔티티를 클라이언트가 보냈을 때 사용                                                                        |
| 416   | Requested Range Not Satisfiabnle | 요청 메시지가 리소스의 특정 범위를 요청했는데 그 범위가 잘못되었거나 맞지 않을 때 사용.                                                                    |
| 417   | Expectation Failed               | 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨 있는 경우 사용.                                                                  |
## 3.4.5 500-599: 서버 에러 상태 코드

| 상태 코드 | 사유 구절                      | 의미                                                                    |
| ----- | -------------------------- | --------------------------------------------------------------------- |
| 500   | Internal Server Error      | 서버가 요청을 처리할 수 없게 만드는 에러 시                                             |
| 501   | Not Implemented            | 클라이언트가 서버의 능력을 넘은 요청 시                                                |
| 502   | Bad Gateway                | 프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용.      |
| 503   | Service Unavailable        | 현재 서버가 요청을 처리해줄 수 없지만 나중에는 가능함을 의미.<br>Retry-After 헤더를 추가 가능(언제 가능한지) |
| 504   | Gateway Timeout            | 408과 유사. 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답         |
| 505   | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받을 시 사용.                   |

# 3.5 헤더

## 3.5.1 일반 헤더

클라이언트, 서버 모두 사용.

| 헤더                       | 설명                                                          |
| ------------------------ | ----------------------------------------------------------- |
| Connection               | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해줌.                     |
| Date                     | 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공                               |
| MIME-Version             | 발송자가 사용한 MIME 버전을 알려줌(Multipurpose Internet Mail Extension) |
| Trailer chunked transfer | 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록 나열                        |
| Transfer-Encoding        | 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 언급                     |
| Upgrade                  | 발송자가 업그레이드하길 바라는 새 버전이나 프로토콜 명시                             |
| Via                      | 이 메시지가 어떤 중개자(프락시, 게이트웨이)를 거쳐왔는지 명시                         |

### 일반 캐시 헤더

HTTP/1.0은 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입.(7장에서 자세히)

| 헤더            | 설명                                  |
| ------------- | ----------------------------------- |
| Cache-Control | 메시지와 함께 캐시 지시자를 전달하기 위해 사용          |
| Pragma        | 메시지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한 X |

## 3.5.2 요청 헤더

요청 메시지를 위한 헤더.

| 헤더         | 설명                           |
| ---------- | ---------------------------- |
| Client-IP  | 클라이언트가 실행된 컴퓨터의 IP           |
| From       | 클라이언트 사용자의 메일 주소             |
| Host       | 요청 대상이 되는 서버의 호스트 명과 포트      |
| Referer    | 현재 요청 URI가 들어있던 문서의 URL      |
| UA-Color   | 클라이언트 기기 디스플레이의 색상 능력에 대한 정보 |
| UA-CPU     | 클라이언트 CPU 종류나 제조사            |
| UA-Disp    | 클라이언트의 디스플레이 능력에 대한 정보       |
| UA-OS      | 클라이언트 기기에서 동작 중인 OS 이름과 버전   |
| UA-Pixels  | 클라이언트 기기 디스플레이에 대한 픽셀 정보     |
| User-Agent | 요청을 보낸 애플리케이션의 이름            |

### Accept 관련 헤더

서버에게 자신의 선호와 능력을 알려줄 수 있다.

| 헤더              | 설명                  |
| --------------- | ------------------- |
| Accept          | 서버가 보내도 되는 미디어 종류   |
| Accept-Charset  | 서버가 보내도 되는 문자 집합    |
| Accept-Encoding | 서버가 보내도 되는 인코딩      |
| Accept-Language | 서버가 보내도 되는 언어       |
| TE(15장에서 자세히)   | 서버가 보내도 되는 확장 전송 코딩 |

### 조건부 요청 헤더

클라이언트는 요청에 몇몇 제약을 넣기도 한다.

| 헤더                  | 설명                                           |
| ------------------- | -------------------------------------------- |
| Expect              | 요청에 필요한 서버의 행동을 열거                           |
| If-Match            | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하는 경우에만 문서를 가져옴    |
| If-Modified-Since   | 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한             |
| If-None-Match       | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하지 않는 경우에만 문서를 가져옴 |
| If-Range            | 서버가 범위 요청을 지원한다면 리소스에 대한 특정 범위 요청            |
| If-Unmodified-Since | 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한                |
| Range               | 문서의 특정 범위에 대한 요청                             |

### 요청 보안 헤더

HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 가짐.(14장에서 자세히)

| 헤더            | 설명                                    |
| ------------- | ------------------------------------- |
| Authorization | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보       |
| Cookie        | 클라이언트가 서버에게 토큰을 전달할 때 사용.             |
| Cookie2       | 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용(11장에서 자세히) |

### 프락시 요청 헤더

인터넷에 프락시가 점점 흔해지면서 그들의 기능을 돕기 위해 정의됨(6장에서 자세히)

| 헤더                  | 설명                                                              |
| ------------------- | --------------------------------------------------------------- |
| Max-Forwards        | 요청이 원 서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. TRACE와 함께 사용됨 |
| Proxy-Authorization | Authorization과 같으나 프락시에서 인증할 때 쓰임                               |
| Proxy-Connection    | Connection과 같으나 프락시에서 연결을 맺을 때 쓰임                               |

## 3.5.3 응답 헤더

응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.

| 헤더          | 설명                                                |
| ----------- | ------------------------------------------------- |
| Age         | 응답이 얼마나 오래되었는지                                    |
| Public      | 서버가 특정 리소스에 대해 지원하는 요청 메서드 목록(응답이 중개자를 통해 왔음을 암시) |
| Retry-After | 현재 리소스가 사용 불가능한 상태일 때 언제 가능해 지는지                  |
| Server      | 서버 애플리케이션의 이름과 버전                                 |
| Title       | HTML 문서에서 주어진 것과 같은 제목                            |
| Warning     | 사유 구절에 있는 것과 더 자세한 경고 메시지                         |

### 협상 헤더

17장에서 자세히

| 헤더            | 설명                                                                                                     |
| ------------- | ------------------------------------------------------------------------------------------------------ |
| Accept-Ranges | 서버가 자원에 대해 받아들일 수 있는 범위의 형태                                                                            |
| Vary          | 서버가 확인해야 하고 그렇기 때문에 응답에 영향을 줄 수 있는 헤더들의 목록 ex) 서버가 클라이언트에게 보내줄 리소스의 가장 적절한 버전을 선택하기 위해 확인해야 하는 헤더들의 목록 |

### 응답 보안 헤더

14장에서 자세히

| 헤더                 | 설명                                                                          |
| ------------------ | --------------------------------------------------------------------------- |
| Proxy-Authenticate | 프락시에서 클라이언트로 보낸 인증 요구 목록                                                    |
| Set-Cookie         | 진짜 보안 헤더는 아니지만 보안에 영향을 줄 수 있다. 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용 |
| Set-Cookie2        | Set-Cookie와 비슷하게 RFC 2965로 정의된 키(11장에서 자세히)                                 |
| WWW-Authenticate   | 서버에서 클라이언트로 보낸 인증요구의 목록                                                     |

## 3.5.4 엔티티 헤더

본문에 대한 헤더.

| 헤더       | 설명                            |
| -------- | ----------------------------- |
| Allow    | 이 에닡티에 대해 수행될 수 있는 요청 메서드 나열  |
| Location | 클라이언트에게 엔티티가 실제로 어디에 위치하고 있는지 |
### 컨텐츠 헤더

엔티티의 컨텐츠에 대한 구체적인 정보를 제공

| 헤더               | 설명                                  |
| ---------------- | ----------------------------------- |
| Content-Base     | 본문에서 사용된 상대 URL을 계산하기 위한 기저 URL     |
| Content-Encoding | 본문에 적용된 어떤 인코딩                      |
| Content-Language | 본문을 이해하는 데 가장 적절한 자연어               |
| Content-Length   | 본문의 길이나 크기                          |
| Content-Location | 리소스가 실제로 어디 위치하는지                   |
| Content-MD5      | 본문의 MD5 체크섬                         |
| Content-Range    | 전체 리소스에서 이 엔티티가 해당하는 범위를 바이트 단위로 표현 |
| Content-Type     | 어떤 종류의 객체인지                         |

### 엔티티 캐싱 헤더

일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지에 대한 지시자를 제공.
엔티티 캐싱 헤더는 엔티티 캐싱에 대한 정보 제공

| 헤더            | 설명                             |
| ------------- | ------------------------------ |
| ETag          | 엔티티에 대한 엔티티 태그                 |
| Expires       | 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
| Last-Modified | 가장 최근 이 엔티티가 변경된 일시            |

## 확장 헤더

개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더.
HTTP 프로그램은 확장 헤더들에 대해 몰라도 용인하고 전달해야 함.
