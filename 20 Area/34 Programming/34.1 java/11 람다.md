# 개요

스트림에서 주로 사용됨

```java
(x, y) -> x * y
```

## 왜 쓰는가?

```java
/* 목차. 1. 인터페이스를 구현하는 클래스로 하위 구현체를 만드는 방법(feat. 자식 클래스 필요) */
Calculator cal = new CalculatorImpl();
System.out.println("(기명)10 + 20 = " + cal.sumTwoNumbers(10, 20)); // 동적 바인딩

/* 목차. 2. 익명 클래스를 활용한 방식(인터페이스 타입으로 하위 구현체 생성) */
Calculator cal2 = new Calculator() { // 자식(구현) 클래스 없애기
    @Override
    public int sumTwoNumbers(int first, int second) {
        return first + second;
    }
};
System.out.println("(익명)30 + 20 = " + cal2.sumTwoNumbers(30, 20));

/* 목차. 3. 람다식을 활용한 방식(메소드명 없애기) */
/* 설명.
*   람다식은 익명함수로 이름을 별도로 작성하지 않지만 인터페이스의 하위 구현체를 생성하며
*   유일하게 있는 추상 메소드를 오버라이딩 하는 개념이기 때문에 익명 함수가 가능하다.
*   즉, 람다식을 활용하기 위한 인터페이스는 추상 메소드를 단 하나만 가져야 한다.
*   그런 인터페이스를 FunctionalInterface 라 한다.
*/
//        Calculator cal3 = (int first, int second) -> {return first + second;};
Calculator cal3 = (first, second) -> first + second;
System.out.println("(람다)2 + 4 = " + cal3.sumTwoNumbers(2, 4));
```

결국 불필요한 코드의 작성을 줄이기 위해 생긴 것.

> 하위 구현체가 생성된다.

각 종류를 모두 외울 필요 없음

그냥 Consumer가 접미사로 붙은 것을 보고 어떤 것이구나 알 수 있으면 됨

기존 제공되는 것들이 많은데 만약 없다면 직접 커스텀해서 만들면 된다.

# Consumer

매개변수 있음. 반환형 없음

# Supplier

매개변수 없음. 반환형 있음

# Function

매개변수 있음. 반환형 있음

# Operator

매개변수 있음. 반환형 있음. 매개변수, 반환형 타입 동일

# Predicate

매개변수 있음. 반환형 있음. 반환형은 boolean임

# 기존 메소드 참조

```java
BiFunction<String, String, Boolean> biFunction;

String str1 = "METHOD";
String str2 = "METHOD";

boolean result = false;

//        biFunction = (x, y) -> x.equals(y);
biFunction = String::equals; // String에 equals() 메소드를 참조하라

result = biFunction.apply(str1, str2);
System.out.println("result: " + result);
```

기존에 있는 메소드를 참조해서 람다식을 정의할 수 있음(커스텀 불가. 있는 거 그대로 쓸 때만)

메소드 참조 표현식

```java
클래스이름::메소드이름 (static)일 경우
참조변수이름::메소드이름 (non-static)일 경우
클래스이름::메소드이름 (non-static)이더라도 아직 객체가 정해지지 않은 경우(참조변수이름이 없을 경우)
```
