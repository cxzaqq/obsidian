
# 개요

애플리케이션이 하드에 있다가 실행하면 메모리에 올라가는데 이를 프로세스라 한다.

프로세스 내부에서 코드의 실행 흐름을 스레드라 한다.

스레드는 한 가지 작업을 실행하기 위해 순차적으로 실행할 코드를 실처럼 이어 놓았다고 해서 유래된 이름.

멀티 프로세스는 그냥 메모장 두 개 켜 놓은 것이라고 생각하면 되고

멀티 스레드는 카톡에서 메시지를 보내면서 파일도 보내는 것이라고 생각하면 된다.

멀티 프로세스는 OS에서 할당받은 자신의 메모리를 가지고 실행하기에 각 프로세스는 독립적이지만 멀티 스레드는 하나의 프로세스 내부에 생성되기에 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있어 다른 스레드에 영향을 미치게 된다.

멀티 스레드는 보통 대용량 데이터의 처리 시간을 줄이기 위해 데이터를 분할해서 병렬로 처리하거나 UI를 가지고 있는 애플리케이션에서 네트워크 통신을 하기 위해 사용된다.

# 메인 스레드

자바의 모든 애플리케이션은 main thread가 main() 메소드를 실행하면서 시작한다.

main thread는 main() 메소드의 첫 코드부터 아래로 순차적으로 실행하고 마지막 코드 혹은 return문을 만나면 종료된다.

main thread는 필요에 따라 작업 스레드들을 만들어서 병렬로 코드를 실행할 수 있다. 즉 멀티 스레드를 생성해서 멀티 태스킹을 수행한다.

싱글 스레드는 메인 스레드 종료 시 프로세스 종료지만 멀티 스레드는 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. 즉 메인 스레드가 종료되어도 다른 작업 스레드가 실행 중이라면 프로세스는 종료되지 않는다.

# 스레드 실행 및 생성

## main thread만 사용

```java
public class BeepPrintExample1 {
	public static void main(String[] args) {
		Toolkit toolkit = Toolkit.getDeafultToolkit();
		for(int i = 0; i < 5; i++) {
			toolkit.beep(); // beep 소리 발생
			try { Thread.sleep(500); } // 0.5초 일시 정지
			catch (Exception e) {}
		}
		
		for(int i = 0; i < 5; i++) {
			System.out.println("띵");
			try { Thread.sleep(500); } // 0.5초 일시 정지
			catch (Exception e) {}
		}
	}
}
```

이 프로그램 실행 시 beep 소리가 모두 울린 후 띵이 출력된다.

## 작업 thread 생성

```java
// beep 소리 작업 정의 implements로 해도 되고 extends로 해도 됨
public class BeepTask implements Runnable {
	public void run() {
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		for(int i = 0; i < 5; i++) {
			toolkt.beep();
			try { Thread.sleep(500); } catch(Exception e) {}
		}
	}
}
```

```java
// main thread와 동시 실행
public class BeepPrintExample2 {
	public static void main(String[] args) {
		Runnable beepTask = new BeepTask();
		Thread thread = new Thread(beepTask);
		thread.start();
		
		for(int i = 0; i < 5; i++) {
			System.out.println("띵");
			try { Thread.sleep(500); } catch(Exception e) {}
		}
	}
}
```

이렇게 하면 동시에 소리와 출력이 가능하다.

```java
// 익명 객체로 구현
public class BeepPrintExample3 {
	public static void main(String[] args) {
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				Toolkit toolkit = Toolkit.getDefaultToolkit();
				for(int i = 0; i < 5; i++) {
					toolkit.beep();
					try { Thread.sleep(500); } catch(Exception e) {}
				}
			}
		});
		thread.start();
		
		for(int i = 0; i < 5; i++) {
			System.out.println("띵");
			try { Thread.sleep(500); } catch(Exception e) {}
		}
	}
}
```

# 동기화 메소드

멀티 스레드 프로그램에서 스레드들이 객체를 공유해서 작업해야 하는 경우가 있다.

하나의 스레드가 공유 객체를 수정해서 다른 스레드에서 의도하지 않은 결과가 나올 수 있다.

스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없게 하려면 스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야 한다.

임계영역: 단 하나의 스레드만 실행할 수 있는 코드의 영역

자바는 임계 영역을 지정하기 위해 동기화 메소드를 제공함

스레드가 객체 내부의 동기화 메소드를 실행하면 즉시 객체에 잠금을 걸어 다른 스레드가 동기화 메소드를 실행하지 못하도록 한다.

## 동기화 하지 않았을 때

```java
public class MainThreadExample {
	public static void main(String[] args) {
		Calculator calculator = new Calculator();
		
		User user1 = new User1();
		user1.setCalculator(calculator);
		user1.start();
		
		User2 user2 = new User2();
		user2.setCalculator(calculator);
		user2.start();
	}
}
```

```java
public class Calculator {
	private int memory;
	
	public int getMemory() {
		return memory;
	}
	
	public void setMemory(int memory) {
		this.memory = memory;
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {}
		System.out.println(Thread.currentThread().getName() + ": " + this.memory);
	}
}
```

```java
public class User1 extends Thread {
	private Calculator calculator;
	
	public void setCalculator(Calculator calculator) {
		this.setName("User1");
		this.calculator = calculator;
	}
	
	public void run() {
		calculator.setMemory(100);
	}
}
```

```java
public class User2 extends Thread {
	private Calculator calculator;
	
	public void setCalculator(Calculator calculator) {
		this.setName("User2");
		this.calculator = calculator;
	}
	
	public void run() {
		calculator.setMemory(50);
	}
}
```

User1이 memory를 100으로 설정하고 2초를 기다리는 사이 User2가 memory를 50으로 설정해서 둘 다 50으로 출력됨

## 동기화 했을 때

```java
public class Calculator {
	private int memory;
	
	public int getMemory() {
		return memory;
	}
	
	public synchronized void setMemory(int memory) {
		this.memory = memory;
	}
	try {
		Thread.sleep(2000);
	} catch(InterruptedException e) {}
	System.out.println(Thread.currentThread().getName() + ": " + this.memory);
}
```

User1이 memory를 사용하는 동안 잠금이 발생해 User2가 접근할 수 없다.

User1이 memory(100)을 출력한 후 User2가 접근하여 50으로 바꾸고 출력한다.

# 스레드 제어

스레드 객체를 생성하고 start() 메소드를 호출하면 바로 실행되는 것이 아니라 실행 대기 상태가 된다. OS는 실행 대기 상태에 있는 스레드 중 하나를 선택해서 실행 상태로 만든다.

실행 상태의 스레드는 run() 메소드를 모두 실행하기 전에 다시 실행 대기 상태로 돌아갈 수 있으며 실행 대기 상태에 있는 다른 스레드가 선택되어 실행 상태가 되기도 한다.(컨텍스트 스위칭)

실행 상태에서 run() 메소드의 내용이 모두 실행되면 스레드의 실행이 멈추고 종료 상태가 된다.

![[thread state.png]]

> stop()은 스레드를 즉시 종료하지만 불완전한 종료를 유발하므로 사용을 지양.

## 1초 후 스레드 중지

### stop flag

```java
public class PrintThread1 extends Thread {
	private boolean stop;
	
	public void setStop(boolean stop) {
		this.stop = stop;
	}
	
	public void run() {
		while(!stop) {
			System.out.println("실행 중");
		}
		System.out.println("자원 정리");
		System.out.pritnln("실행 종료");
	}
}
```

```java
public class StopFlagExample {
	public static void main(String[] args) {
		PrintThread1 printThread = new PrintThread1();
		printThread.start();
		
		try {
			Thread.sleep(1000); // 메인 스레드를 중지
		} catch (InterruptedException e) {}
		
		printThread.setStop(true);
	}
}
```

### interrupt 메소드 사용

```java
public class InterruptExample {
	public static void main(String[] args) {
		Thread thread = new PrintThread2();
		thread.start();
		
		try { Thread.sleep(1000); } catch (InterruptedException e) {}
		
		thread.interrupt();
	}
}
```

```java
public class PrintThread2 extends Thread {
	public void run() {
		try {
			while(true) {
				System.out.println("실행 중");
				Thread.sleep(1); // 스레드 일시 정지
			}
		} catch(InterruptedException e) {}
		
		System.out.println("자원 정리");
		System.out.println("실행 종료");
	}
}
```

스레드가 실행, 실행 대기에 있을 때는 interrupt() 메소드가 실행되면 즉시 예외가 발생하지 않고 스레드가 이후 일시 정지 상태가 되면 예외가 발생한다.

즉 interrupt() 메소드 호출 후 스레드가 일시 정지 상태가 되지 않으면 interrupt() 호출은 의미가 없다.

# 데몬 스레드

주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드. 주 스레드 종료 시 데몬 스레드 강제 종료. ex) 워드 프로세서의 자동 저장, 미디어 플레이어의 동영상 및 음악 재생, Garbage Collector

```java
public class AutoSaveThread extends Thread {
	public void save() {
		System.out.println("작업 내용을 저장함");
	}
	
	@Override
	public void run() {
		while(true) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				break;
			}
			save();
		}
	}
}
```

```java
public class DaemonExample {
	public static void main(String[] args) {
		AutoSaveThread autoSaveThread = new AutoSaveThread();
		autoSaveThread.setDaemon(true); // AutoSaveThread를 데몬 스레드로 만든다.
		autoSaveThread.start();
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {}
		
		System.out.println("메인 스레드 종료");
	}
}
```

start() 메소드가 호출되고 나서 setDaemon(true);를 호출하면 IllegalThreadStateException이 발생하기 때문에 start() 호출 전에 데몬 스레드로 설정해야 한다.
