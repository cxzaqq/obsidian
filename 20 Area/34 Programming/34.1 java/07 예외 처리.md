# 개요

JVM은 프로그램을 실행하는 도중 예외가 발생하면 해당 예외 클래스로 객체를 생성함.

모든 예외 클래스는 java.lang.Exception 클래스를 상속받는다.

![[Exception.png]]

예외가 발생 -> 예외 객체가 생성된다.

# Checked Exception

컴파일 시점에 처리해야 하는 예외. 컴파일러가 미리 확인하고 이를 처리하기 위한 try-catch 혹은 throws를 반드시 작성해야 함

# Unchecked Exception

컴파일 시점이 아닌 런타임 시점에 발생하는 예외. 명시적으로 처리하지 않아도 됨

자바 컴파일러가 체크하지 않기에 오로지 개발자의 경험에 의해 예외 처리 코드를 작성해야 한다. 만약 실행 예외에 대해 예외 처리 코드를 넣지 않았을 경우 해당 예외 발생 시 프로그램이 곧바로 종료된다.

## NullPointerException

가장 흔하게 일어나는 예외

객체 참조가 없는 상태. 즉 null 값을 갖는 참조 변수로 객체 접근 연산자 `.`를 사용했을 때 발생

## ArrayIndexOutOfBoundsException

배열 접근 시 배열의 인덱스 범위를 초과할 경우 발생

## NumberFormatException

숫자 타입이 아닌 데이터를 숫자로 변경하려고 하면 발생

## ClassCastException

관련 클래스가 아닌데 타입 변환을 하려고 하면 발생

# 예외 처리 코드

```java
public class TryCatchFinallyExample {
	public static void main(String[] args) {
		try {
			Class clazz = Class.forName("java.lang.String2");
		} catch(ClassNotFoundException e) {
			System.out.println("클래스가 존재하지 않습니다");
		}
		
		String data1 = null;
		String data2 = null;
		
		try {
			int value1 = Integer.parseInt(data1);
			int value2 = Integer.parseInt(data2);
			int result = value1 + value2;
			System.out.println(data1 + "+" + data2 + "=" + result);
		} catch(NumberFormatException e) {
			System.out.println("숫자로 변환할 수 없습니다.");
		} finally {
			System.out.println("다시 실행하세요");
		}
	}
}
```

### 다중 catch

여러 예외에 대응하기 위해 catch를 여러 개 작성할 수 있는데 모두 실행되는 것이 아니라 하나의 catch만 실행된다. 왜? 예외가 터지면 즉시 실행을 멈추고 catch로 가기 때문

### catch 순서

다중 catch 블록을 작성할 때 주의할 점

상위 예외 클래스가 하위 예외 클래스보다 아래 위치해야 함.

```java
...
try {
	/*
	여기서 ArrayIndexOutOfBoundsExecption이든 NumberFormatException이든 발생하면
	첫번째 catch 블럭으로 이동함 왜?
	Exception이 상위 클래스이기 때문
	즉 catch(Exception e)는 맨 뒤로 가야 한다. 모든 예외의 상위 객체이기 때문
	*/
} catch(Exception e) {
	...
} catch(ArrayIndexOutOfBoundsException e) {
	...
}
```

## 예외 떠넘기기

보통 try-catch 블록으로 예외를 처리하는 게 기본이지만 경우에 따라 메소드를 호출한 곳으로 예외를 떠넘길 수 있다.

이때 사용하는 키워드가 `thorws`임.

> throws 키워드가 붙어 있는 메소드는 반드시 try 블록 내에서 호출해야 한다.

```java
public class ThrowsExample {
	public static void main(String[] args) {
		try {
			findClass();
		} catch(ClassNotFoundException e) {
			System.out.println("클래스가 존재하지 않습니다.");
		}
	}
	
	public static void findClass() throws ClassNotFoundException {
		Class clazz = Class.forName("java.lang.String2");
	}
}
```

> throws ClassNotFoundException을 작성 안 해도 동일하게 동작하는데 작성하는 이유? throws는 선언부기에 호출하는 곳에서 어떤 예외가 일어날 수 있는지 확인하고 대응할 수 있게 하기 위해

> main에서 throws를 하면 JVM한테 던지는 것임

- 주의

```java
public class SuperClass {
    public void method() throws IOException {
			...
    }
}
```

```java
public class SubClass extends SuperClass {

    /* 설명. 부모 메소드의 예외 클래스와 같은 레벨일 땐 문제 X */
//    @Override
//    public void method() throws IOException {
//    }

    /* 설명. 부모 메소드와 달리 예외를 발생시키지 않아도 문제되지 않는다. */
//    @Override
//    public void method() {
//    }

    /* 설명. 부모 메소드보다 더 낮은 레벨(자식 예외 클래스)을 발생시켜도 문제 X */
//    @Override
//    public void method() throws FileNotFoundException {
//    }

    /* 설명. 부모 메소드보다 더 높은 레벨(부모 예외 클래스)을 발생 시키면 컴파일 에러  */
//    @Override
//    public void method() throws Exception {
//    }

}
```

# try with resource

자바 7버전에서 추가된 기능으로 입출력에서 사용되는 스트림의 자원 반납(close())을 finally 블럭을 사용하지 않고 용이하게 처리하기 위해 도입된 문법이다.

```java
try (BufferedReader in = new BufferedReader(new FileReader("test.dat"));){
	
	String s;
	
	while((s = in.readLine()) != null){
		System.out.println(s);
	}

} catch (FileNotFoundException/* | EOFException*/ e) {
	e.printStackTrace();

} catch (IOException e) {
	e.printStackTrace();
}
```
