# 개요

데이터의 타입을 일반화한다.

T, E, K, V를 활용

각 Type, Element, Key, Value임

## 사용 이유?

구현의 편의성과 타입의 안정성을 동시에 챙기기 위해

- 제네릭 클래스는 다양한 자료형으로 변할 수 있어 클래스 하나만으로 활용가치가 높아진다.(구현의 편의성)
- 매개변수나 반환형도 제네릭 타입으로 지정되어 명확히 해당 타입에 대해 처리할 수 있다.(타입의 안정성)

```java
public class GenericTest<T> {
    private T value;

    public GenericTest() {
    }

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}

```

T가 변할 수 있는 것. (원시 타입은 불가)

# 와일드카드 제네릭

이미 제네릭 객체가 메모리에 생성돼 있을 때 제한을 거는 것.

```java
// 인스턴스를 필터링 하기 위한 기능
public class WildCardFarm {
    public void anyType(RabbitFarm<?> farm) { // Rabbit 또는 그 하위 타입 모두 가능
        farm.getRabbit().cry();
    }

    public void extendsType(RabbitFarm<? extends Bunny> farm) { // Bunny 또는 Bunny 하위 타입
        farm.getRabbit().cry();
    }

    public void superType(RabbitFarm<? super Bunny> farm) { // Bunny 또는 Bunny 상위 타입
        farm.getRabbit().cry();
    }
}

```

```java
/* Rabbit혹은 Rabbit을 상속 받은 클래스만 사용 가능 */
public class RabbitFarm<T extends Rabbit> {
    private T rabbit;

    public RabbitFarm() {
    }

    public RabbitFarm(T rabbit) {
        this.rabbit = rabbit;
    }

    public T getRabbit() {
        return rabbit;
    }

    public void setRabbit(T rabbit) {
        this.rabbit = rabbit;
    }
}

```
