# 개요

## 변수 사용 이유?

재사용, 가독성, 유지보수

```java
int intValue;      // 변수 선언: 메모리 할당
intValue = 1;      // 변수 초기화 : 해당 메모리에 값 할당
int intValue2 = 2  // 선언과 초기화를 한 번에
```

```java
int intValue;

intValue = intValue + 1; // 에러
```

## **왜 변수를 꼭 초기화 후 사용해야 할까?**

변수를 선언하면 메모리를 할당하는데 그 메모리 공간을 이전에 다른 프로그램 혹 변수가 사용했던 공간이라면 어떤 값이 있을지 모름.

변수를 선언 후 초기화 하지 않고 사용도 안 하면 컴파일 시 최적화 과정에서 그냥 없어짐 (사용하지 않는 변수는 그냥 메모리만 차지하기에)

즉 초기화를 해야 생성되는 것임.

# 원시 자료형(primitive type)

## 정수형

| 타입    | 할당되는 메모리 크기 | 데이터 표현 범위                 |
| ----- | ----------- | ------------------------- |
| byte  | 1 바이트       | $-128$ ~ $127$            |
| short | 2 바이트       | $-2^{15}$ ~ $(2^{15} -1)$ |
| int   | 4 바이트       | $-2^{31}$ ~ $(2^{31} -1)$ |
| long  | 8 바이트       | $-2^{63}$ ~ $(2^{63} -1)$ |

## 실수형

|타입|할당되는 메모리 크기|데이터 표현 범위|
|---|---|---|
|float|4 바이트|$(3.4 * 10^{-38})$ ~ $(3.4 * 10^{38})$|
|double|8 바이트|$(1.7 * 10^{-308})$ ~ $(1.7 * 10^{308})$|

실수형은 부동소수점 방식으로 값을 저장하는데 0.1을 정확하게 저장할 수 없다.

- 왜?
    
    이진수 변환 과정에서의 한계임
    
    0.1을 2진수로 변환해 보면 0.1(10) = 0.0001100110011001100110011…(2)
    
    무한히 반복하는 2진수가 됨.
    
    결국 double이나 float가 크기가 제한되어 있기에 일정 비트까지만 저장하고 나머지는 자름(반올림). 즉 정확한 값이 아니라 근사치가 저장됨.
    

## 문자형

|타입|할당되는 메모리 크기|데이터 표현 범위|
|---|---|---|
|char|2 바이트|0 ~ $2^{16}$|

## 논리형

|타입|할당되는 메모리 크기|데이터 표현 범위|
|---|---|---|
|boolean|1 바이트|true 혹은 false|

int(long), double, boolean, String만 보통 사용

메모리 비용이 워낙 저렴하기에 메모리 용량을 약간 절약하기 위해 타입을 바꾸는 것보다는 개발 속도나 효율에 초점을 맞추는 것이 더 효과적이다

# 참조 자료형(reference type)

## 문자열

## 기타..(추후 학습)

# 변수 명명 규칙

## 컴파일

1. 동일한 범위 내에서 동일한 변수명을 가질 수 없다.
2. 변수의 이름에는 자바에서 사용 중인 키워드(예약어)를 사용할 수 없다.
3. 변수의 이름은 영문자 대소문자를 구분한다.
4. 변수의 이름은 숫자로 시작할 수 없다.
5. 특수기호는 '_'와 '$'만 사용 가능하다.

## 암묵적 규칙

1. 변수명의 길이 제한은 없다. (변수명의 길이는 프로그램 실행과는 무관하기에 제한은 없지만 코드는 결국 사람이 읽는 것. 너무 길어도 좋지 않다)
2. 변수명이 합성어로 이루어진 경우 첫 단어는 소문자, 두 번째 시작 단어는 대문자로 시작한다. (camelCase)
3. 단어와 단어 사이의 연결을 언더스코어( _ )로 하지 않는다. (타 언어 네이밍 규칙이다.)
4. 한글로 변수명을 짓는 것이 가능하지만, 권장하지 않는다. (한글을 취급하는 다양한 방식들이 존재하기 때문에 에러를 유발할 수 있다.)
5. 변수 안에 저장된 값이 어떤 의미를 가지는지 명확하게 표현하도록 한다.
6. 전형적인 변수 이름이 있다면 가급적 사용하도록 한다.
7. 명사형으로 작성할 수 있도록 한다.
8. boolean 형은 의문문으로 가급적 긍정 의문문 형태로 네이밍한다. (isDeleted)

# 스코프

변수는 해당 코드 블록 안에서만 생존

## 왜 스코프가 존재해야 하는가?

- 효율적인 메모리 사용을 위해
- 코드의 복잡성을 낮추기 위해

# 시스템입출력

```java
System.out.println();
/*
System: 시스템이 가지고 있는
out: 출력 장치로
println: 출력 후 행 바꿈
*/
```

```java
int keyCode = System.in.read();
/*
System: 시스템이 가지고 있는
in: 입력 장치에서
read: 입력된 키코드를 읽어라
*/
```

`System.in.read()`는 키코드를 하나씩 읽기에 2개 이상의 키가 조합된 한글은 읽을 수 없음.

그래서 `Scanner` 사용

# 상수

상수는 변수와 동일하게 데이터를 저장할 수 있는 공간이지만 한 번 메모리에 저장되면 변경할 수 없다.

```java
final int AGE;
```

## 명명 규칙

모든 문자는 영어 대문자 혹은 숫자만 사용

단어와 단어 연결은 언더바 사용 `_`

# 형변환

## 자동형변환

컴파일러가 자동으로 수행해주는 타입 변환. 데이터 손실 가능성이 없는 경우 자동으로 맞춰줌

![[Type Casting.png]]

> 8Byte인 long보다 4Byte의 float의 범위가 더 넓은 이유? long은 정수만 표현하지만 float은 소수도 표현하면서 지수로도 표현하여 실제로 다루는 값이 훨씬 크다
> 
> long은 범위가 제한적이지만 모든 정수를 정확히 표현
> float은 범위가 넓지만 소수점과 지수로 표현하면서 정밀도가 떨어져 근사값만 저장됨

- 정수 → 실수
- 문자형 → int
- 논리형은 형 변환 규칙에서 제외된다

큰 타입과 작은 타입 연산 시 큰 타입으로 자동으로 변환된다.

## 강제형변환

데이터 손실 가능

```java
long lNum = 3000000000L;
int iNum = (int) lNum;

System.out.println("long : " + lNum); // long : 3000000000
System.out.println("int  : " + iNum); // int  : -1294967296
```