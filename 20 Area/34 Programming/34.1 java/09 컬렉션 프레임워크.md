# 개요

널리 알려져 있는 자료구조를 사용해서 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 있도록 인터페이스와 구현 클래스를 java.util 패키지에서 제공하는데 이를 총칭해서 컬렉션 프레임워크라 함.

즉 자바에서 데이터를 저장하고 활용하는 데 사용되는 유용한 도구

컬렉션은 객체의 저장을 뜻하고 프레임워크는 사용 방법을 정해놓은 라이브러리를 말함.

![[collection framwork.png]]

## 사용 이유

1. 일관된 API
    
    Collection 에서 제공하는 규격화된 메소드를 사용함으로 일관된 사용과 유지보수가 가능하다.
    
2. 프로그래밍 비용 감소
    
    이미 제공된 자료구조를 활용하는 것으로 low-level의 알고리즘을 고민할 시간과 노력을 아낄 수 있다.
    
3. 프로그래밍 속도 및 품질 향상
    
    필요한 자료구조를 사용함으로써 프로그래밍의 속도 뿐만 아니라 기동 속도, 품질 향상을 기대할 수 있다.
    

보통 웹 자바 개발자는 ArrayList, HashMap을 주로 사용함

Iterable? 순회가 가능하다

# List

배열과 비슷하게 객체를 인덱스로 관리한다. 차이점은 저장 용량이 자동으로 증가하며 추가, 삭제, 검색을 위한 다양한 메소드들이 제공됨

객체 자체를 저장하는 것이 아니라 객체의 번지를 참조함

```java
List<String> list = ...;
list.add("hi");               // 맨 끝에 객체 추가
list.add(1, "what");          // 지정된 인덱스에 객체 삽입
String str = list.get(1);     // 인덱스로 객체 검색
list.remove(0);               // 인덱스로 객체 삭제
list.remove("what");          // 객체 삭제
```

```java
// 리스트 순회
for (int i = 0; i < list.size(); i++) { ... }
for (Stirng str : list) { .. }
```

## ArrayList

List 인터페이스의 대표적인 구현 클래스. (동적 배열)

```java
List<String> list = new ArrayList<String>();  // 정석
List<String> list = new ArrayList<>();        // 생략 가능
```

기본 생성자로 ArrayList 객체를 생성하면 내부에 10개의 객체를 저장할 수 있는 초기 용량(capacity)을 가지게 된다. 저장되는 객체 수가 늘어나면 용량이 자동으로 증가한다.

객체를 추가하면 0번부터 차례로 저장된다.

객체를 인덱스 중간에 삽입, 삭제 시 내부적으로는 해당 인덱스 이후를 모두 밀거나 당긴다.

즉 빈번한 객체 삽입, 삭제가 일어나는 곳에서는 ArrayList를 사용하는 것이 바람직하지 않다. (LinkedList 사용하는 것이 좋음) But 조회는 성능이 좋음

## Vector

ArrayList와 동일한 내부 구조를 가지고 있다. Vector를 생성하기 위해서는 저장할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 됨

```java
List<E> list = new Vector<E>();  // 정석
List<E> list = new Vector<>();   // 생략 가능
```

ArrayLIst와 다른 점?

Vector는 동기화된 메소드로 구성되어 있기에 멀티 스레드가 동시에 Vector 메소드를 실행할 수 없고 하나의 스레드가 메소드를 실행 완료해야만 다른 스레드가 메소드를 실행할 수 있다.

따라서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. 이것을 thread safe(스레드의 안전)하다고 표현함.

근데 현업에서도 ArrayList로 동기화를 구현함. Vector 잘 안 씀

## LinkedList

사용법은 ArrayList와 같지만 내부 구조는 완전히 다르다.

ArrayList는 내부 배열에 객체를 저장해서 관리하지만 LinkedList는 인접 참조를 링크해서 체인처럼 관리함.

삽입, 삭제 시 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않음.

ArrayList는 중간에서 삽입, 삭제 시 뒤에 있는 인덱스가 모두 밀리거나 당겨져야 함. 따라서 삽입, 삭제 시에는 LinkedList가 성능이 더 좋음

But 조회, 수정 시에는 성능이 떨어짐. get.(10)을 하면 10번째를 바로 꺼내는 게 아니라 첫 번째부터 하나하나 타고 가면서 10번째를 찾기 떄문.

데이터가 많아질수록 차이가 극명함

```java
List<E> list = new LinkedList<E>();  // 정석
List<E> list = new LinkedList<>();   // 생략 가능
```

> 10,000 개의 객체 삽입 성능 비교 ArrayList: 20248953ms (0.0202초) LinkedList: 4279517ms (0.0043초)

### 순회

```java
for (String item: list) {
	System.out.println(item);
}
```

내부적으로 Iterator를 사용하므로 remove()는 불가 ⇒ 사용자가 직접 Iterator를 다룰 수 없기에

```java
Iterator<String> iterator = list.iterator();
while(iterator.hasNext()) {           // 역순 가능 hasPrevious()
	String item = iterator.next();      // 역순 가능 previous()
	System.out.println(item);
}
```

안전하게 remove() 호출 가능

```java
list.forEach(System.out::println);
```

Stream API 이용(나중에 자세히)

### Stack

LIFO

### Queue

FIFO

# Set

List는 객체의 저장 순서를 유지하지만 Set은 저장 순서가 유지되지 않는다.

또한 객체를 중복 저장 불가하고 null도 하나만 저장 가능

Set은 인덱스로 객체를 검색해서 가져오는 메소드가 없다.

대신 전체 객체를 대상으로 한 번씩 반복해서 가져오는 반복자(Iterator)를 제공함.

## hashSet

```java
Set<String> set = new HashSet<String>();    // 정석
Set<String> set = new HashSet<>();          // 생략 가능
```

객체들을 순서 없이 저장하고 중복 저장 X.

HashSet이 판단하는 동일한 객체란 꼭 같은 인스턴스를 뜻하는 건 아님.

hashCode() 리턴값이 같으면 equals()를 호출. equals()도 같으면 동등 객체로 인식하여 저장하지 않는다.

클래스 생성 후 사용자가 직접 hashCode()와 equals()를 재정의 하면 사용자 정의 Set도 사용 가능

## TreeSet

TreeSet 클래스는 데이터가 정렬된 상태로 저장되는 이진 검색 트리의 형태로 요소를 저장한다.

이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠르다.

# Map

키, 값으로 구성된 객체.

키, 값 모두 객체로 구성됨. ⇒ 키나 값에 원시 타입을 넣으면 auto boxing 일어남

값은 중복 저장 가능하지만 키는 불가

## 순회

```java
// Iterator 사용
Map<K, V> map = ...;
Set<K> keySet = map.keySet(); // key 집합(Set<K>)를 가져옴
Iterator<K> keyIterator = keySet.iterator();
while(keyIterator.hasNext()) {
	K key = keyIterator.next();
	V value = map.get(key);
}
```

키만 필요할 때 가볍고 메모리 효율적.

```java
// Map.Entry 사용
Set<Map.Entry<K, V>> entrySet = map.entrySet();
Iterator<Map.Entry<K, V>> entryIterator = entrySet.iterator();
while(entryIterator.hasNext()) {
	Map.Entry<K, V> entry = entryIterator.next();
	K key = entry.getKey();
	V value = entry.getValue();
}
```

map.get(key) 호출이 없어 키, 값이 모두 필요할 때 더 효율적

하지만 Map.Entry 객체 생성으로 메모리 사용 증가

대부분의 경우 entrySet()이 성능 면에서 더 유리함.

## HashMap

```java
Map<K, V> map = new HashMap<K, V>();   // 정석
Map<K, V> map = new HashMap<>();       // 생략 가능
```

hashCode()와 equals()를 재정의하여 특정 필드들이 같을 시 같은 키로 인식하게 할 수 있다.

## HashTable

HashMap과 동일한 내부 구조

HashMap는 동기화된 메소드로 구성되어 있기에 멀티 스레드가 동시에 HashMap메소드를 실행할 수 없고 하나의 스레드가 메소드를 실행 완료해야만 다른 스레드가 메소드를 실행할 수 있다.

따라서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. 이것을 thread safe(스레드의 안전)하다고 표현함

## Properties

HashTable을 상속 받아 구현한 것으로 (Object, Object)의 형태로 저장하는 해시 테이블과 달리 (String, String) 형태로 저장. 주로 환경 설정과 관련된 속성을 저장하는 데 사용

Key, Value 모두 String 이기 때문에 제네릭이 필요하지 않다.
