# 개요

입출력 스트림과 다르다

배열, 컬렉션을 편하게 다루도록 하는 기술

# Stream 특징

- 원본을 변경하지 않는 읽기 전용
- 스트림은 `iterator`처럼 한 번만 사용되고 사라진다.
- 최종 연산 전까지 중간 연산이 처리되지 않는다.
- 병렬 처리가 용이하다

# Stream 가공

|**상세 역할**|**메소드**|
|---|---|
|필터링|filter(), distinct()|
|변환|map(), flatMap()|
|제한|limit(), skip()|
|정렬|sorted()|
|결과 확인|peek()|

## filter

특정 데이터만 걸러내는 메소드. 매개변수로 받는 `Predicate`는 `boolean`을 리턴하는 함수형 인터페이스

```java
Stream<T> filter(Predicate<? super T> predicate);
```

## map

값을 가공할 수 있는 람다식을 매개변수로 받아 데이터를 가공하고 새로운 스트림에 담아준다.

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
```

## flatMap

중첩 구조를 한 단계 제거하고 단일 컬렉션으로 만들어 준다.

```java
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
```

## sorted

스트림에 있는 데이터들을 정렬할 때 사용한다.

# 병렬 스트림

원래 보통 순회 시 cpu의 코어를 1개의 사용하는데 병렬 스트림을 사용하면 여러 개의 코어를 사용할 수 있다.

⇒ log만큼 연산이 줄어든다. (8번 연산 필요한 게 3번으로 줄어들 수 있다.)

```java
int coreCount = Runtime.getRuntime().availableProcessors();
System.out.println("CPU 코어 수: " + coreCount);

/* 수업목표. Stream에 대해 이해하고 활용할 수 있다. */
/* 설명.
*   Arrays.asList(): 매개변수로 요소들을 전달하면 List로 반환
*   ArrayList<>(Collection 타입): Collection 타입을 ArrayList 객체로 생성할 때 쓰이는 생성자 */
List<String> stringList = Arrays.asList(
        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S");

/* 설명. main 스레드 상에서 스트림을 사용하지 않고 확인 */
System.out.println("=== for each ===");
for (String str : stringList) {
    System.out.println(str + " || " + Thread.currentThread().getName());
}
System.out.println();

/* 설명. main 스레드 상에서 단순 스트림을 사용하고 확인 */
System.out.println("=== normal stream ===");
//        stringList.stream().forEach(x -> Application1.print(x));
stringList.forEach(x -> Application1.print(x)); // 컬렉션은 stream() 생략 가능
System.out.println();

/* 설명. main 스레드 상에서 병렬 스트림을 사용하고 확인 */
System.out.println("=== parallel stream ===");
stringList.parallelStream().forEach(Application1::print); // cpu 코어들을 효율적으로 사용해 성능 향상
System.out.println();
}

private static void print(String x) {
System.out.println(x + " || " + Thread.currentThread().getName());
}
```

---
# `Stream<Integer>` vs `IntStream`

|        | `Stream<Integer>`        | `IntStream`            |
| ------ | ------------------------ | ---------------------- |
| 타입     | Object Stream            | Primitive Stream       |
| 포함 데이터 | Integer 객체(Wrapper Type) | int 타입(Primitive Type) |
| 성능/효율  | 상대적으로 비효율적(오토 박싱/언박싱 발생) | 상대적으로 효율적(오버헤드 감소)     |
```java
List<Integer> result = new ArrayList<>();
...
int[] intArr = result.stream().mapToInt(Integer::intValue).toArray();

/*
result.stream()의 타입은 Stream<Integer> 즉 Object Stream이다.
result.stream().mapToInt(Integer::intValue)의 타입은 IntStream 즉 Primitive Stream이다.

result.stream().mapToInt(i -> i.intValue()).toArray();

List<String> words = Arrays.asList("apple", "banana", "kiwi");
IntStream lengths = words.stream().mapToInt(String::length);
이런 방식으로도 사용 가능

IntStream mapToInt(ToIntFunction<? super T> var1);

mapToInt()는 인수로 ToIntFunction이라는 함수형 인터페이스를 받는다.
ToIntFunction<T> 인터페이스는 java.util.function 패키지에 정의되어 있고
int applyAsInt(T value)라는 추상 메서드를 가진다.
즉 T 타입을 int 타입으로 반환하는 것이다.

<? super T>의 의미는 와일드 카드의 한 종류로 T 타입이거나 T의 상위 타입을 의미한다.
*/
```