# 개요

참조 타입이란 객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스를 말한다.

![[data type.png]]

메모리는 여러 구역으로 나눠져 있는데 그 중 스택과 힙 영역이 사용된다.

![[reference type memory.png]]

## JVM 메모리 영역

조금 더 자세히 알기 위해 JVM이 사용하는 메모리 영역에 대해 알아보자

![[JVM memory.png]]

### 메서드 영역

JVM이 시작할 때 생성되고, 모든 스레드가 공유하는 영역. 메서드 영역에는 코드에서 사용되는 클래스들을 클래스 로더로 읽어 클래스별로 정적 필드(static field)와, 상수(constant pool), 메서드 코드, 생성자(constructor) 코드 등을 분류해서 저장한다.

### 힙 영역

객체와 배열이 생성되는 영역. 여기에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조.

참조가 이뤄지지 않는 객체나 배열은 GC가 자동으로 제거함.

### 스택 영역

JVM 스택은 메서드를 호출할 때마다 프레임을 추가하고 메서드가 종료되면 해당 프레임을 제거함. 프레임에 스택 구조로 해당 메서드에 사용되는 변수들이 들어감

## 참조 타입의 `==`, `!=` 연산

기본 타입 변수는 변수의 값이 같은지 아닌지를 비교하지만 참조 타입은 동일한 객체를 참조하는지 아닌지를 비교한다. 결국 번지 값이 비교되는 것

## null, NullPointerException

참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 `null`값을 가질 수 있다.

참조 타입이 객체를 참조하다가 null 값을 가지면 더 이상 객체를 참조하지 않는 것이므로 GC가 메모리에서 해당 객체를 삭제함(다른 참조가 없을 경우)

자바는 프로그램 실행 도중 발생하는 오류를 예외 `exception`이라 함.

참조 변수 사용 시 가장 많이 발생하는 오류가 `NullPointerException` 인데 이는 참조 변수가 null 값을 가지고 있을 경우 발생함.

# String

자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다. (constant pool)

```java
String name1 = "roy";
String name2 = "roy";

name1 == name2; // true => 참조하는 객체가 같다는 뜻
```

만약 이걸 분리하고 싶다면 `new`라는 객체 생성 연산자를 사용하면 된다.

```java
String name1 = new String("roy");
String name2 = new String("roy");

name1 == name2; // false => 참조하는 객체다 다르다는 뜻  
```

번지수와 상관 없이 안에 문자열 내용을 비교하고 싶을 때는 `equals`를 사용하면 된다.

```java
name1.equals(name2); // true
```

# 배열

## 개요

배열은 동일한 자료형(Data Type)의 묶음이다. 연속된 메모리 공간에 값을 저장하고 사용하기 위한 용도로 사용된다. 배열은 heap 영역에 new 연산자를 통해 할당된다. 또한 배열의 길이는 최초 선언한 값으로 **“고정”** 되며, 인덱스를 통해 데이터에 접근할 수 있다.

RAM에는 크게 세 가지의 파트가 있는데

- static
	static으로 선언된 것들이 여기에 올려짐. 프로그램의 실행과 동시에 종료까지 계속 여기 있음
- heap 변수가 가리키는 데이터가 있음
- stack 모든 변수는 스택에 쌓임(참조 타입은 주소가 담기고(무조건 4Byte) 원시 타입은 그냥 값이 담긴다).

![[array declaration.png]]

힙 영역에 올라가는 순간 각 타입의 기본값이 채워진다.

> 정수: 0
> 실수: 0.0
> 논리: false
> 문자: \u0000
> 참조: null


```java

int[] arr = new int[5];
System.out.println("arr = " + arr);

// arr = [I@4dd8dc3
// [: 배열, I: 타입(Integer), @: at, 4dd8dc3: 16진수 주소

// 기본 자료형이 아니면 모두 toString()이 적용돼서 나옴

// int[] arr; => 스택에만 올라감
// arr = new int[5]; => 힙에 기본 값으로 들어감
```

개발자가 직접 주소값을 건드릴 수 없다.

힙 영역 내에 old라는 영역이 또 있음

데이터를 더 이상 참조하지 않으면 이 old라는 영역으로 들어가고 GC가 주기적으로 old를 비워줌

```java
cArr = new char[5];
cArr = null;
System.out.println(cArr.hashCode());
// NullPointerException 참조 에러. cArr이 가리키는 주소가 없어서 참조할 수 없기에
```

선언과 동시에 초기화

```java
int[] iArr2 = new int[]{10, 11, 12, 13, 14}; // 이게 정석
int[] iArr = {10, 11, 12, 13, 14}; // 생략도 가능
```

주의

```java
public static void test(int[] arr) {
	...        
}
/*
여기서 이 int[] arr의 파라미터는 배열 자체를 의미하는 게 아니라 가리키는
주소값을 받아오는 것임
*/

test({10, 11, 12, 13, 14});               // 에러남
test(new int[]{10, 11, 12, 13, 14});      // 가능
```

## 2차원 배열

![[two dimensional array declaration.png]]

## 배열의 복사

### 깊은 복사(deep copy)

같은 크기의 같은 값을 갖는 배열을 만든다.(원본, 사본)

![[deep copy.png]]

> 힙의 배열에 저장한 값을 복사 (원본, 사본)

깊은 복사 방법에는 4가지가 있다.

- for문을 이용한 동일한 인덱스 값들끼리의 복사
- Object의 clone()을 이용한 복사
- System.arraycopy()를 이용한 복사
- Arrays.copyOf()를 이용한 복사

보통 clone을 자주 사용함.

### 얕은 복사(shallow copy)

여러 변수가 같은 배열의 주소를 가리키게 만드는 것(원본)

![[shallow copy.png]]

> 스택의 주소값만 복사 (원본은 하나고 이름이 여러개)

call by reference: 파라미터로 참조 타입을 보내면 얕은 복사가 일어나는 것(공유)

call by value: 그냥 값만 넘어오기에 원본에는 영향 X

## 객체를 참조하는 배열

그렇다면 배열의 타입이 String[]이면 메모리 구조가 어떻게 될까?

```java
String[] strArr = new String[3];
strArr[0] = "Java";
strArr[1] = "C++";
strArr[2] = "C#";
```

2차원 배열처럼 배열 안에 참조 값이 들어간다.

![[reference type array memory.png]]

# 열거 타입

## 개요

한정된 값인 열거 상수 `enumeration constant` 중에서 하나의 상수를 저장하는 타입.

자바에서 객체의 체크 제약 조건

```java
# Week.java

public enum Week {
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	SUNDAY
}

Week today; // 변수 선언
today = Week.FRIDAY; // Week에 선언된 7개 중 하나만 넣을 수 있음

public enum LoginResult { LOGIN_SUCCESS, LOGIN_FAILED }
/*
enum 타입의 이름은 첫 글자를 대문자, 이후 camelCase
enum 값이 여러 단어로 구성될 경우 모두 대문자, 이후 snake_case
*/

Week birthday = null;
// 열거 타입도 참조 타입이기에 null 가능. 즉 열거 상수는 객체임!
```

![[enum memory.png]]

```java
Week today = Week.SUNDAY;
```

이 구문은 메모리 구조가 어떻게 될까?

![[enum variable memory.png]]

서로 같은 객체를 참조하기에 `today == Week.SUNDAY;` 는 `true`가 나온다.

---

접근 시 각각에 필드에 맞는 객체가 생성됨

SINGLETON하게 생성됨.

자신의 타입의 객체가 생성되어 들어간 것

```java
public enum Subjects {
    JAVA,
    MARIADB,
    JDBC,
    HTML,
    CSS,
    JAVASCRIPT;
    
    Subjects() {
        System.out.println("기본 생성자 실행됨");
    }
    
    /* 설명. 모든 객체에 적용됨 */
    @Override
    public String toString() {
        return "@@@" + this.name() + "@@@";
    }
}
```

하나만 접근해도 ex) Subjects subject1 = Subjects.JAVA; ⇒ 각 필드의 생성자가 실행됨 (6번)

그 이후는 생성되지 않는다. ⇒ 싱글톤

즉

- 열거 타입으로 선언된 인스턴스는 싱글톤으로 관리되며 인스턴스가 각각 한 개임을 보장한다. 작성한 순서에 따라 각각 다른 인스턴스가 생성되며 최초 호출 시에 enum의 생성자를 활용해 생성된다. (lazy singleton 개념)
- 단일 인스턴스를 보장하기에 == 비교(동일 비교)가 가능하다.

```java
/* 설명. 상수 필드명을 문자열로 변경하기 쉽다. */
System.out.println(Subjects.JAVA.toString()); // 재정의하여 사용 가능
// 재정의 시 모든 객체에 적용됨
System.out.println(Subjects.JAVA.name());     // 재정의 불가
```

```java
/* 설명. values()를 이용하면 상수값 배열을 반환받고 순회 가능. */
// 상수 필드들에 주입된 객체들을 순회 가능.
Subjects[] subjects = Subjects.values();
for(Subjects subject : subjects) {
System.out.println(subject.toString());
}
```

값 대입

```java
public enum UserRole2 {
    GUEST("게스트"),
    CONSUMER("구매자"),
    PRODUCER("판매자"),
    AMDIN("관리자");

    private final String DESCRIPTION;

    UserRole2(String description) { // 값 대입 시 생성자를 명시해야 함
        DESCRIPTION = description;
    }

    public String getDESCRIPTION() {
        return DESCRIPTION;
    }
}
```