# 뷰 (B)

하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블

뷰가 정의된 기본 테이블 혹은 뷰를 삭제하면 해당 뷰도 삭제됨
CREATE, DROP 사용

# 파티션의 종류 (B)

### 범위 분할

지정한 열의 값을 기준으로 분할함
ex) 일별, 월별, 분기별 등

### 해시 분할

해시 함수를 적용한 결과 값에 따라 데이터를 분할함

데이터를 고르게 분산할 때 유용.
특정 데이터가 어디에 있는지 판단 불가
ex) 고객번호, 주민번호 등(과 같이 데이터가 고른 컬럼에 효과적)

### 조합 분할

범위 분할로 분할한 후 해시 함수를 적용하여 다시 분할하는 방식

범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용

# 분산 데이터베이스의 목표 (B)

### 위치 투명성

DB의 실제 위치를 알 필요 없이 단지 DB의 논리적 명칭만으로 접근 가능

ex) 고객은 온라인 쇼핑몰에서 상품을 조회 시 그 상품 정보가 어디에 있든 그냥 ID만으로 조회 가능(백엔드가 알아서 찾아옴)
### 중복 투명성

동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고 시스템은 자동으로 여러 자료에 대한 작업을 수행함

ex) 어디 DB에 있더라도 사용자가 한 ㅂ너 업데이트하면 나머지는 시스템이 자동으로 동기화
### 병행 투명성

분산 DB와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음

ex) 여러 사용자가 동시에 하나의 상품을 구매 시 재고가 1개라면 시스템이 자동으로 하나만 처리하고 나머지는 실패 처리

### 장애 투명성

트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리함

ex) 서울 서버가 다운되어도 시스템이 자동으로 부산 서버에 저장하거나 재시도함. 사용자는 에러를 못 느낌

# RTO/RPO (A)

### RTO(Recovery Time Objective, 목표 복구 시간)
비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미함

### RPO(Recovery Point Objective, 목표 복구 시점)
비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미함

# 암호화 (C)

### 암호화 기법
- 개인키 암호 방식
- 공개키 암호 방식

# 임의 접근통제 (A)

DAC(Discretionary Access Control)

데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
- 데이터 소유자가 접근통제 권한을 지정하고 제어
- 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여 받고 부여된 권한을 다른 사용자에게 허가 가능능

# 강제 접근 통제 (A)

MAC(Mandatory Access Control)

주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
- 시스템이 접근 통제 권한을 지정
- DB 객체 별로 보안 등급 부여 가능
- 사용자 별로 인가 등급 부여 가능

# 역할기반 접근 통제 (A)

RBAC(Role Based Access Control)

사용자의 역할에 따라 접근 권한을 부여하는 방식
- 중앙관리자가 접근 통제 권한을 지정
- 임의 접근 통제와 강제 접근 통제의 권한을 지정
- 다중 프로그래밍 환경에 최적화된 방식

즉 역할에 권한을 주고 사람은 역할만 부여받으면 됨

# DAS (B)

Direct Attached Storage
서버와 저장장치를 전용 케이블로 직접 연결하는 방식

# NAS (C)

Network Attached Storage
서버와 저장장치를 네트워크를 통해 연결하는 방식

# SAN (B)

Storage Area Network
DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식
서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식

- 광 채널(Fibre Channel) 스위치를 이용하여 네트워크를 구성 => 처리 속도가 빠름
- 서버들이 저장장치 및 파일을 공유 가능

# 자료 구조의 분류 (B)

- 선형 구조: 배열, 선형 리스트, 스택, 큐, 데크
- 비선형 구조: 트리, 그래프

# 스택 (B)

LIFO
초과 삽입 시 Overflow, 초과 삭제 시 Underflow

# 데크 (B)

Deque => Double_Ended Queue

삽입, 삭제가 양쪽 끝에서 모두 발생 가능

입력 제한: 입력은 한 쪽에서만, 출력은 양쪽에서
출력 제한: 입력은 양쪽에서, 출력은 한 쪽에서만

# 방향/무방향 그래프의 최대 간선 수 (B)

방향 그래프의 최대 간선 수: n(n - 1)

무방향 그래프에서 최대 간선 수: n(n - 1) / 2

# 트리 (C)

정점(Node), 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태

# 트리 관련 용어 (B)

근 노드: 최상위 노드

차수: 각 노드에서 뻗어나온 가지의 수

단말 노드: 자식이 없는 즉 차수가 0인 노드

레벨: 근 노드의 level을 1로 두고 그 자식은 +1씩

깊이: 노드가 가질 수 있는 최대의 레벨

숲: 여러 개의 트리가 모여 있는 것

트리의 디그리: 노드들의 차수 중 가장 많은 수

![[트리.png]]
# Preorder 운행법 (B)

이진 트리를 Root -> Left -> Right 순으로 탐색
ABDHIECFG
# Inorder 운행법 (B)

이진 트리를 Left -> Root -> Right 순으로 탐색
HDIBEAFCG

# Postorder 운행법 (B)

이진 트리를 Left -> Right -> Root 순으로 탐색
HIDEBFGCA

# Infix 표기를 Prefix로 바꾸기 (C)

X = A / B * (C + D) + E => X + * / A B + C D E
연산자를 해당 피연산자 두 개의 앞(왼쪽)에 오도록 이동
# Infix 표기를 Postfix로 바꾸기 (C)

X = A / B * (C + D) + E => X A B / C D + * E + =
연산자를 해당 피연산자 두 개의 뒤(오른쪽)에 오도록 이동

# Postfix 표기된 수식을 Infix로 바꾸기 (B)

A B C - / D E F + * + => A / (B - C) + D * (E + F)

# 삽입 정렬 (B)

두 번째 요소부터 크기에 맞게 좌측에 삽입

초기 상태: 8 5 6 2 4
1회전: 5 8 6 2 4
2회전: 5 6 8 2 4
3회전: 2 5 6 8 4
4회전: 2 4 5 6 8

평균, 최악 시간 복잡도: O(n<sup>2</sup>)
# 선택 정렬 (B)

최소값을 찾아 첫 번째 삽입, 첫 번째 제외한 최소값 찾아 두 번째 삽입...

초기 상태: 8 5 6 2 4
1회전: 2 8 5 6 4
2회전: 2 4 8 5 6
3회전: 2 4 5 8 6
4회전: 2 4 5 6 8

평균, 최악 시간 복잡도: O(n<sup>2</sup>)
# 버블 정렬 (B)

인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 위치를 교환

초기 상태: 8 5 6 2 4
1회전: 5 6 2 4 8
2회전: 5 2 4 6 8
3회전: 2 4 5 6 8

평균, 최악 시간 복잡도: O(n<sup>2</sup>)

# 퀵 정렬 (B)

분할, 정복을 통해 자료를 정렬. 피봇 사용

보통 피벗은 맨 앞 요소를 선택함

초기 상태: 6, 3, 8, 5, 2, 7, 4, 1
1단계: {3, 5, 2, 4, 1}, `6`, {8, 7}
2단계: {2, 1}, `3`, {5, 4}, 6, {8, 7}
3단계: {1}, `2`, 3, {4}, `5`, 6, {8, 7}
2단계: 1, 2, 3, 4, 5, 6, {7}, `8`
최종: {1, 2, 3, 4, 5}, `6`, {7, 8}

최악 시간 복잡도: (n(n - 1)) / 2

# 힙 정렬 (C)

완전 이진 트리를 이용한 정렬 방식
완전 이진 트리를 heap tree로 변환하여 정렬

초기 상태: 6, 3, 8, 5, 2, 7, 4, 1
- 배열을 최대 힙으로 만든다
=> 8, 5, 7, 3, 2, 6, 4, 1
- 최대값을 꺼내고 끝과 교체 후 다시 힙정렬
=> 1, 5, 7, 3, 2, 6, 4, 8
=> 7, 5, 6, 3, 2, 1, 4, 8
- 반복
=> 4, 5, 6, 3, 2, 1, 7, 8
=> 6, 5, 4, 3, 2, 1, 7, 8

=> 1, 5, 4, 3, 2, 6, 7, 8
=> 5, 3, 4, 1, 2, 6, 7, 8

=> 2, 3, 4, 1, 5, 6, 7, 8
=> 4, 3, 2, 1, 5, 6, 7, 8

=> 1, 3, 2, 4, 5, 6, 7, 8
=> 3, 1, 2, 4, 5, 6, 7, 8

=> 2, 1, 3, 4, 5, 6, 7, 8

=> 1, 2, 3, 4, 5, 6, 7, 8

평균, 최악 시간 복잡도: O(nlog<sub>2</sub>n)

# 2-Way 합병 정렬 (C)

이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식

{6, 3, 8, 5, 2, 7, 4, 1}
→ {6, 3, 8, 5} + {2, 7, 4, 1}
→ {6, 3} + {8, 5} + {2, 7} + {4, 1}
→ {6} + {3}, {8} + {5}, {2} + {7}, {4} + {1}
→ {3, 6}, {5, 8}, {2, 7}, {1, 4}
→ {3, 5, 6, 8} + {1, 2, 4, 7}
→ {1, 2, 3, 4, 5, 6, 7, 8}

평균, 최악 시간 복잡도: O(nlog<sub>2</sub>n)