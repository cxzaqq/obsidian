
# 소프트웨어 아키텍처 (C)

소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체

기본 원리
- 모듈화
- 추상화
- 단계적 분해
- 정보 은닉

# 모듈화 (A)

시스템의 기능들을 모듈 단위로 나누는 것

모듈 간 결합도의 최소화, 모듈 내 요소들의 응집도를 최대화 하는 것이 목표

# 추상화 (B)

문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화해 나가는 것

- 과정 추상화
	자세한 수행 과정을 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계하는 방법
- 자료 추상화
	데이터의 세부적인 속성이나 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
- 제어 추상화
	이벤트 발생의 정확한 절차나 방법을 정의하지 않고 대표할 수 있는 표현으로 대체하는 방법

# 단계적 분해 (C)

상위의 중요 개념으로부터 하위의 개념으로 구체화하는 분할 기법
Niklaus Wirth에 의해 제안된 하향식 설계 전략

# 정보 은닉 (B)

한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

# 협약에 의한 설계 (B)

컴포넌트를 설계 시 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것

명세에 포함될 조건
- 선행 조건: 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
- 결과 조건: 오퍼레이션이 수행된 후 만족되어야 할 조건
- 불변 조건: 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

# 아키텍처 패턴 (C)

아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

종류
- 레이어 패턴
- 클라이언트-서버 패턴
- 파이프-필터 패턴
- 모델-뷰-컨트롤러 패턴

# 레이어 패턴 (C)

시스템을 계층으로 구분하여 구성하는 고전적 방법의 패턴
서로 마주보는 두 계층 사이에서만 상호작용이 이뤄짐
OSI 참조 모델이 대표적

# 클라이언트-서버 패턴 (C)

하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

# 파이프-필터 패턴 (B)

데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴

데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
UNIX의 Shell이 대표적

# 모델-뷰-컨트롤러 패턴 (B)

서브 시스템을 3개의 부분으로 구조화
- 모델: 서브시스템의 핵심 기능과 데이터를 보관
- 뷰: 사용자에게 정보를 표시함
- 컨트롤러: 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄냄

# 기타 패턴 (B)

- 마스터-슬레이브 패턴(병렬 컴퓨팅)
	슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴
- 브로커 패턴(분산 환경 시스템)
	사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴
- 피어-투-피어 패턴(파일 공유 네트워크)
	피어라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴
- 이벤트-버스 패턴(알림)
	소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 패턴
- 블랙보드 패턴(음성 인식)
	모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴
- 인터프리터 패턴(번역기)
	프로그램 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성된 패턴

# 객체 지향 (C)

소프트웨어의 각 요소들을 객체로 만든 후 객체들을 조립해서 소프트웨어를 개발하는 기법

구성 요소
- 객체
- 클래스
- 메시지

특징
- 캡슐화
- 상속
- 다형성
- 연관성

# 객체 (C)

데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈

# 클래스 (B)

공통된 속성과 연산을 갖는 객체의 집합
틀
클래스에 속한 객체를 인스턴스라 함

# 메시지 (B)

객체의 동작이나 연산을 일으키는 외부 요구 사항

# 캡슐화 (B)

외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것
결합도가 낮아짐
# 상속 (B)

상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

# 다형성 (C)

하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력

# 연관성 (C)

두 개 이상의 객체들이 상호 참조하는 관계

- is member of
	연관화: 2개 이상의 객체가 상호 관련되어 있음을 의미
- is instance of
	분류화: 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
- is part of
	집단화: 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것
- is a
	일반화: 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
	특수화/상세화: 상위 객체를 구체화하여 하위 객체를 구성하는 것

# 객체지향 분석 (B)

Object Oriented Analysis
사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업

# 객체지향 분석의 방법론 (B)

럼바우: 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행
부치: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하며 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
Jacobson: 유스케이스를 강조하여 사용
Coad, Yourdon: ER 다이어그램을 사용하여 객체의 행위를 모델링, 객체 십력, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성
Wirfs-Brok: 분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행

# 럼바우의 분석 기법  (A)

모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법

객체 모델링 기법(OMT, Object Modeling Technique)

분석 활동은 객체 모델링 -> 동적 모델링 -> 기능 모델링 순으로 이뤄짐

- 객체 모델링: 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 모델링
- 동적 모델링: 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
- 기능 모델링: 자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

# 객체지향 설계 원칙  (A)

SRP(단일 책임): 객체는 단 하나의 책임만 가져야 함
OCP(개방-폐쇄): 기존 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 함
LSP(리스코프 치환): 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 함
ISP(인터페이스 분리): 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 함
DIP(의존 역전): 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 함