# 개요

인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.

개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킨다.

그렇기에 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다.

그렇다면 왜 객체의 메소드를 직접 호출하지 않고 중간에 인터페이스를 두고 사용할까?

개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서.

인터페이스는 하나의 객체가 아니라 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하느냐에 따라 실행 내용과 반환값이 다를 수 있다.

즉 개발 코드 측면에서 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다는 장점을 가진다.

![[interface.png]]

물리적으로(.java ⇒ .class)는 클래스와 동일하지만 작성법이 다르다.

인터페이스는 상수 필드와 추상 메소드만을 구성 멤버로 갖는다.

인터페이스는 객체로 생성할 수 없기에(인스턴스화 불가) 생성자를 가질 수 없다.

# 작성법

```java
interface RemoteControl{
	// 상수: 선언과 동시에 초기값을 지정해야 함.
	public static final int MAX_VOLUME = 10; // 이게 정석인데
	int MIN_VOLUME = 0; // public static final은 고정이라 생략해도 된다.
	
	// 추상 메소드: 선언부만 작성
	public abstract void turnOn(); // 정석
	void turnOff(); // 생략 가능
	void setVolume(int volume);
}
```

객체는 인터페이스에서 정의된 추상 메소드와 동일한 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다. 이런 객체를 인터페이스의 구현 객체(implement object)라 하고 구현 객체를 생성하는 클래스를 구현 클래스라 함

## 구현 클래스

```java
public class Television implements RemoteControl {
	private int volume;
	
	// 추상 메소드의 실체 메소드
	public void turnOn() {
		System.out.println("TV를 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("TV를 끕니다.");
	}
	
	// 인터페이스 상수를 이용해서 volume 필드의 값을 제한
	public void setVolume(int volume) {
		if(volume > RemoteControl.MAX_VOLUME) {
			this.volume = RemoteControl.MAX_VOLUME;
		} else if(volume < RemoteControl.MIN_VOLUME) {
			this.volume = RemoteControl.MIN_VOLUME;
		} else {
			this.volume = volume;
		}
		System.out.println("volume: " + this.volume);
	}
}
```

> 인터페이스의 모든 메소드는 기본적으로 public 접근 제한자를 갖는다.

```java
public class RemoteControlExample {
	public static void main(String[] args) {
		RemoteControl rc;
		rc = new Television();
	}
}
```

## 다중 인터페이스 구현 클래스

```java
public interface Searchable {
	void search(String url);
}
```

```java
public class SmartTelevision implements RemoteControl, Searchable {
	private int volume;
	
	public void turnOn() { ...	}
	
	public void turnOff() { ...	}
	
	public void setVolume(int volume) { ...	}
	
	public void search(String url) {
		System.out.println(url + "을 검색합니다.");
	}
}
```

두 인터페이스를 구현하고 있다.

따라서 각 타입의 변수에 각각 대입할 수 있다.

```java
public class SmartTelevisionExample {
	public static void main(String[] args) {
		SmartTelevision tv = new SmartTelevesion();
		
		RemoteControl rc = tv;
		Searchable searchable = tv;
	}
}
```

# 인터페이스 사용

클래스를 선언할 때 인터페이스는 필드, 생성자 또는 메소드의 매개변수, 생성자 또는 메소드의 로컬 변수로 선언될 수 있다.

```java
public MyClass {
	// 필드
	RemoteControl rc = new Television();
	
	// 생성자
	MyClass(RemoteControl rc) {
		this.rc = rc;
	}
	
	// 메소드
	void methodA() {
		// 로컬 변수
		RemoteControl rc = new Audio();
	}
	
	// 매개값으로 구현 객체 대입
	void methodB(RemoteControl rc) { ... }
}
```

# 인터페이스의 다형성

인터페이스를 사용해서 메소드를 호출하도록 코딩했다면 구현 객체를 매우 손쉽고 빠르게 교체할 수 있다. 프로그램 소스 코드는 변함이 없는데 구현 객체를 교체함으로써 프로그램의 실행 결과가 다양해지는데 이게 인터페이스의 다형성이다.

## 자동 타입 변환

구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환이다.

인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환될 수 있다.

### 필드의 다형성

```java
public interface Tire {
	public void roll();
}
```

```java
public class HankookTire implements Tire {
	@Overrid
	public void roll() {
		System.out.println("한국 타이어 굴러간다");
	}
}
```

```java
public class KumhoTire implements Tire {
	@Overrid
	public void roll() {
		System.out.println("금호 타이어 굴러간다");
	}
}
```

```java
public class Car {
	Tire frontLeftTire = new HankookTire();
	Tire frontRgihtTire = new HankookTire();
	Tire backLeftTire = new HankookTire();
	Tire backRgihtTire = new HankookTire();
	
	void run() {
		frontLeftTire.roll();
		frontRightTire.roll();
		backLeftTire.roll();
		backRightTire.roll();
	}
}
```

```java
public class CarExample {
	public static void main(String[] args) {
		Car myCar = new Car();
		
		myCar.run();
		/*
		한국 타이어 굴러간다.
		한국 타이어 굴러간다.
		한국 타이어 굴러간다.
		한국 타이어 굴러간다.
		*/
		
		myCar.frontLeftTire = new KumhoTire();
		myCar.frontRightTire = new KumhoTire();
		
		myCar.run();
		/*
		금호 타이어 굴러간다.
		금호타이어 굴러간다.
		한국 타이어 굴러간다.
		한국 타이어 굴러간다.
		*/
	}
}
```

필드를 손쉽게 갈아끼울 수 있다.

### 매개 변수의 다형성

자동 타입 변환은 필드의 값을 대입할 때도 발생하지만 주로 메소드를 호출할 때 많이 발생함.

매개값을 다양화하기 위해 상속에서는 매개 변수를 부모 타입으로 선언하고 호출할 때에는 자식 객체를 대입했다.

이번에는 매개 변수를 인터페이스 타입으로 선언하고 호출할 때는 구현 객체를 대입한다.

```java
public class Driver {
	public void drive(Vehicle vehicle) {
		vehicle.run();
	}
}
```

```java
public interface Vehicle {
	public void run();
}
```

```java
public class Bus implements Vehicle {
	@Override
	public void run() {
		System.out.println("버스 달림");
	}
}
```

```java
public class Taxi implements Vehicle {
	@Override
	public void run() {
		public void run() {
			System.out.println("택시 달림");
		}
	}
}
```

```java
public class DriverExample {
	public static void main(String[] args) {
		Driver driver = new Driver();
		
		Bus bus = new Bus();
		Taxi taxi = new Taxi();
		
		driver.drive(bus);   // 버스 달림
		driver.drive(taxi);  // 택시 달림
	}
}
```

Bus, Taxi가 자동으로 Vehicle 타입으로 변환된 것

## 강제 타입 변환

구현 객체가 인터페이스 타입으로 자동 타입 변환되면 인터페이스에 선언된 메소드만 사용 가능하다는 제약이 생김

하지만 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우 강제 타입 변환을 해서 다시 구현 클래스 타입으로 변환하여 해당 필드와 메소드를 사용 가능

```java
public interface Vehicle {
	public void run();
}
```

```java
public class Bus implements Vehicle {
	@Override
	public void run() {
		System.out.println("버스 달림");
	}
	
	public void checkFare() {
		System.out.println("승차 요금 체크");
	}
}
```

```java
public class VehicleExample {
	public static void main(String[] args) {
		Vehicle vehicle = new Bus();
		
		vehicle.run();        // 버스 달림
		// vehicle.checkFare(); // 불가
		
		Bus bus = (Bus) vehicle;
		
		bus.run();            // 버스 달림
		bus.checkFare();      // 승차 요금 체크
	}
}
```

### 객체 타입 확인

강제 타입 변환 또한 구현 객체가 인터페이스 타입으로 변환되어있을 경우에만 가능

따라서 타입을 확인해야 함

```java
public class Driver {
	public void drive(Vehicle vehicle) {
		if(vehicle instanceof Bus) { // vehicle이 참조하는 객체가 Bus인가?
			Bus bus = (Bus) vehicle;   // 안전하게 타입 변환
			bus.checkFare();           // 변환이 필요한 이유
		}
		vehicle.run();
	}
}
```

# 인터페이스 상속

인터페이스도 다른 인터페이스를 상속할 수 있다. 클래스와는 달리 다중 상속 가능

상속된 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드뿐만 아니라 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 함. 그렇기에 구현 클래스로부터 객체를 생성한 후 타입 변환이 가능하다.

하위 인터페이스로 타입 변환이 되면 상위 및 하위에서 선언된 모든 메소드를 사용 가능하지만 상위 인터페이스로 타입 변환되면 상위의 메소드만 사용 가능하다.

```java
// 상위
public interface InterfaceA {
	public void methodA();
}
```

```java
// 상위
public interface InterfaceB {
	public void methodB();
}
```

```java
// 하위
public interface InterfaceC extends InterfaceA, InterfaceB {
	public void methodC();
}
```

```java
public class ImplementationC implements InterfaceC {
	public void methodA() {
		sout("ImplementationC-methodA() 실행");
	}
	
	public void methodB() {
		sout("ImplementationC-methodB() 실행");
	}
	
	public void methodC() {
		sout("ImplementationC-methodC() 실행");
	}
}
```

```java
public class Example {
	public static void main(String[] args) {
		ImplementationC impl = new ImplementationC();
		
		InterfaceA ia = impl;
		ia.methodA();
		
		InterfaceB ib = impl;
		ib.methodB();
		
		InterfaceC ic = impl;
		ic.methodA();
		ic.methodB();
		ic.methodC();
	}
}
```

- 마커 인터페이스?

서로 다른 두 타입을 하나의 타입으로 만들 때 사용하는 인터페이스

인터페이스끼리는 implements가 아니라 extends로 사용하고 다중 상속도 가능하다

```java
public interface ParentInterProduct { ... }
```

```java
public interface AnotherParentInterProduct { ... }
```

```java
public interface InterProduct extends ParentInterProduct, AnotherParentInterProduct {
	...
}
```

> 인텔리제이에서 다이어그램으로 시각화 가능
> ctrl + alt + shift + u

# 추상 클래스 vs 인터페이스

|구분|추상 클래스|인터페이스|
|---|---|---|
|상속 가능 범위|단일 상속|다중 상속|
|키워드|extends 사용|implements 사용|
|추상 메소드 개수|abstract 메소드 0개 이상|모든 메소드는 abstract|
|abstract 키워드 명시|명시적 사용|묵시적으로 abstract|
|사용 목적|is-a 관계(상속을 통한 확장)|can-do 관계 (기능 제공)|

## 추상 클래스 사용 시기

- 기본적인 상태(필드)를 공유해야 할 때
- 몇 개의 메서드는 공통 구현을 제공하고, 나머지는 하위 클래스가 구현해야 할 때
- `is-a` 관계를 표현할 때 (예: `Animal` → `Dog`, `Cat`)

즉 공통적인 속성과 동작을 가진 클래스를 만들 때 사용

## 인터페이스 사용 시기

- 여러 클래스에서 동일한 동작(기능)을 강제하고 싶을 때
- 다중 구현이 필요할 때
- `can-do` 관계를 표현할 때 (예: `Flyable`, `Serializable`)

즉 특정 기능을 여러 클래스에서 공통으로 사용하게 할 때 사용