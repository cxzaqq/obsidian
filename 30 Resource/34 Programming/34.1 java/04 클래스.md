# 클래스의 구성

## 필드

객체의 데이터가 저장되는 곳. 변수와 다름

필드는 객체 생성 시 자동으로 해당 타입의 기본 초기값으로 설정됨.

| 타입      | 기본값          |
| ------- | ------------ |
| byte    | 0            |
| short   | 0            |
| int     | 0            |
| long    | 0L           |
| float   | 0.0f         |
| double  | 0.0d         |
| char    | \u000 (널 문자) |
| boolean | false        |
| 참조 타입   | null         |

## 생성자

객체 생성 시 초기화 역할 담당. 클래스 이름으로 되어 있음. 반환 값 없음.

new 연산자로 객체를 인스턴스화 할 때 호출되어 객체의 초기화를 담당

즉 생성자가 성공적으로 실행되어야 힙 영역에 인스턴스가 생성되고 해당 번지가 반환됨

모든 클래스에는 생성자가 반드시 존재하며 하나 이상 가질 수 있다.

생성자를 생략하면 컴파일 시 .class 파일에 자동으로 기본 생성자가 생성됨

```java
# Car.java

public class Car { ... };

=> 컴파일

# Car.class

public class Car {
	public Car() { } // 자동으로 추가됨
}
```

하지만 명시적으로 선언한 생성자가 한 개라도 있을 시 컴파일러는 기본 생성자를 추가하지 않는다.

클래스에 생성자가 명시적으로 선언되었을 경우 반드시 선언된 생성자를 호출해서 객체를 생성해야 함

```java
# Car.java
// 클래스 파일
public class Car {
	Car(String color, int cc) { }
}
```

```java
# CarExample.java
// 실행 파일
public class CarExample {
	public static void main(String[] args) {
		Car myCar = new Car("black", 3000);
		// Car myCar = new Car();; // 에러
	}
}
```

이렇게 매개변수를 통해 생성할 수도 있고 애초에 기본값을 줄 수도 있음

```java
public class Korean {
	// 필드
	String nation = "대한민국";
	String name;
	String ssn;
	
	// 생성자
	public Korean(String n, String s) {
		name = n;
		ssn = s;
	}
}

Korean k1 = new Korean("roy", "011222-1234123");
```

여기서 매개 변수를 각 n, s라고 했는데 name, ssn으로 하면 앞의 name, ssn을 필드로 인식 못하고 매개변수로 인식함. 그래서 this를 사용

this를 사용하면 객체 자신을 뜻하기에 `this.name` 하면 필드를 의미

```java
public class Korean {
	// 필드
	String nation = "대한민국";
	String name;
	String ssn;
	
	// 생성자
	public Korean(String name, String ssn) {
		this.name = name;
		this.ssn = ssn ;
	}
}
```

- **생성자 오버로딩**

객체를 생성할 때 외부에서 제공되는 데이터가 없다면 기본 생성자로 객체를 생성하고 외부에서 데이터가 제공되면 해당 데이터를 사용해서 객체를 생성할 수 있어야 함.

```java
public class Car {
	String company = "현대자동차";
	String model;
	String color;
	int maxSpeed;
	
	Car() { }
	
	Car(String model) {
		this.model = model;
	}
	
	Car(String model, String color) {
		this.model = model;
		this.color = color;
	}
	
	Car(String model, String color, int maxSpeed) {
		this.model = model;
		this.color = color;
		this.maxSpeed = maxSpeed;
	}
}
```

근데 이러면 중복 코드가 많아짐 이를 this() (자신의 다른 생성자를 호출)로 해결할 수 있음

```java
public class Car {
	String company = "현대자동차";
	String model;
	String color;
	int maxSpeed;
	
	Car() { }
	
	Car(String model) { // 1
		this(model, "흰색", 200); // 기본 색상, 기본 최고 속도 지정하여 3를 실행
	}
	
	Car(String model, String color) { // 2
		this(model, color, 200); // 기본 최고 속도 지정하여 3을 실행
	}
	
	Car(String model, String color, int maxSpeed) { // 3
		this.model = model;
		this.color = color;
		this.maxSpeed = maxSpeed;
	}
}
```

---

> 주의!

```java
Memeber member1 = new Memer();
```

new를 통해 힙 영역에 올려줘라고 하는데 이를 인스턴스화(instanciation)이라 함

즉 메모리에 올라간 객체가 인스턴스

```java
member1.name = "홍길동";
```

이런 구문이 있으면 클래스에 값이 저장되는 게 아니라 메모리 구조를 항상 같이 떠올려라.

클래스는 그저 구조일 뿐

![[class-instance memory.png]]

힙에 올라온 인스턴스의 name이라는 공간에 값이 저장되는 것

```java
...
Monster monster2 = new Monster();
monster2.name = "프랑켄";
monster2.setHp(-300);

// # Monster.java
public class Monster {
	int hp;
	
	public void setHp(int hp) {
		if(hp >= 0) this.hp = hp; // monster2가 호출
		else this.hp = 0; // monster2가 호출
	}
}
```

this.은 이 메소드를 호출한 객체를 의미. 즉 여기서는 monster2.

this.hp는 힙에 올라가 있는 monster2가 가리키고 있는 주소에 있는 인스턴스에서의 hp를 의미

절대 클래스 자체에서 호출한 게 아님

---

## 메소드

객체의 동작에 해당하는 실행 블록. 매개, 반환 값 사용 가능

> 사용 목적 코드의 중복 회피, 가독성, 유지보수

메소드는 선언부와 실행 블록으로 구성됨

선언부를 메소드 시그니처라고 함.

메소드 선언 즉 시그니처는 메소드 이름, 리턴 타입, 매개 변수(순서)로 구분됨

```java
public class Application1 {
    public static void main(String[] args) {
		    System.out.println("main() 시작함...");
        methodA();
        System.out.println("main() 종료함...");
    }
    
     public static void methodA() {
     System.out.println("methodA() 호출됨..");
     System.out.println("methodA() 종료됨..");
    }
    
}

// void: 반환값 없음
// static: 자바사 시작할 때부터 인식하는 것(메모리에 올라가는 것)
/*
static을 사용하지 않고 인지시키고 싶다면
new 연산자를 통해 중간에 인식하게 할 수 있음

모든 메소드를 static으로 하면 시작할 때 부하가 걸릴 수 있음 
*/

public class Application2 {
    public static void main(String[] args) {
        System.out.println("main() 시작함...");
        Application2 app = new Application2();
        app.methodA();
        System.out.println("main() 종료함...");
    }
    
    public void methodA() {
        System.out.println("methodA() 호출됨..");
        System.out.println("methodA() 종료됨..");
    }
}
```

> 즉 호출 시 new 하지 않으면 다 static 메소드임.

그러면 모든 메소드에 static을 붙이면 되지 않나?

⇒ static이 모두 붙으면 프로그램 실행 시 그 모든 메소드를 인지(메모리에 로드)해야 하기 때문에 부하가 커짐. new를 사용해서 중간에 인식하게 하여 부하를 줄일 수 있음

### 전달인자, 매개변수

```java
public class Application3 {
	public static void main(String[] args) {
	
	Application3 app3 = new Application3();
	app3.testMethod(13);               // 메소드 호출과 함께 사용되는 변수를 전달인자라 함
	}
	
	public void testMethod(int age) {  // 메소드가 호출되어 실행 시 사용되는 변수를 매개변수라 함
		System.out.println(age);
	}
}
```

- **메소드에서 매개 변수의 개수를 모를 경우**

```java
// 배열 사용
int sum1(int[] values) {
	int sum = 0;
	for (int i = 0; i < values.length; i++) {
		sum += values[i];
	}
	return sum;
}

// 호출
int[] values1 = {1, 2, 3};
int result1 = sum1(values1);

// ... 사용
int sum2(int ... values) {
	int sum = 0;
	for (int i = 0; i < values.length; i++) {
		sum += values[i];
	}
	return sum;
}

// 호출
int result2 = sum2(1, 2, 3);

// ...도 결국 배열 타입이지만 호출 시에 더 편함
```

### **메소드 오버로딩**

같은 이름의 메소드를 여러 개 정의하는 것. 리턴 타입은 같아도 되고 달라도 됨. 매개 변수의 타입, 개수, 순서가 달라야 함.

근데 그러면 어떻게 구분하는가? 시그니처로 구분

자바는 메서드의 이름 뿐만 아니라 매개변수 정보를 함께 사용해서 메서드를 구분한다.

따라서 이름이 같고 매개변수가 다른 메서드를 정의할 수 있다.

이것이 오버로딩(과적)

즉 이름이 같은 메서드를 여러 개 정의했다는 것

주의: 반환 타입은 구분할 때 사용하지 않는다 즉

```java
int add(int a, int b);
double add(int a, int b);
```

이 경우는 오버로딩 실패(컴파일 오류: 같은 메서드를 두 번 정의 했다고 뜸)

또한 매개 변수 이름이 아닌 타입으로 구분하기에

```java
int add(int a, int b);
int add(int c, int d);
```

이것 또한 실패

하지만 순서는 구분하기에

```java
int add(int a, double b);
int add(double a, int b);
```

이건 성공

**메서드 시그니처**

시그니처 = 메서드 이름 + 매개변수 타입(순서)

# 인스턴스 멤버와 정적 멤버

객체마다 필드 값이 달라야 한다면 해당 필드는 객체마다 가지고 있는 것이 맞지만 객체의 필드 값이 모두 같아야 한다면 이걸 객체마다 가지고 있는 것은 메모리 낭비이다.

자바는 이런 경우를 위해 클래스 멤버를 인스턴스 멤버와 정적 멤버로 구분해서 선언할 수 있도록 한다.

인스턴스 멤버: 객체마다 가지고 있는 멤버

정적 멤버: 객체들이 공유하는 멤버

## 인스턴스 멤버

우선 인스턴스 멤버 생성 시 메모리 구조를 보자

```java
public calss Car {
	int gas;
	int speed;
	
	void setSpeed(int speed) {
	  this.speed = speed;
  }
}

Car myCar = new Car();
myCar.gas = 10;
myCar.setSpeed(60);

Car yourCar = new Car();
yourCar.gas = 20;
yourCar.setSpeed(80);
```

![[instance memory.png]]

메소드는 따로 생기지 않고 메소드 영역에 저장되고 공유된다. 여러 개일 필요가 없기에

객체의 인스턴스 필드를 사용할 때는 this를 사용하면 됨

## 정적 멤버

정적 멤버는 클래스에 고정된 멤버로 객체를 생성하지 않고 사용할 수 있는 필드와 메소드.

```java
public class Calculator {
	String color;                     // 인스턴스 멤버
	static double pi = 3.14159;       // 정적 멤버
	
	void setColor(String color) {     // 인스턴스 메소드
		this.color = color;
	}
	
	static int plus(int x, int y) {    // 정적 메소드
		return x + y;
	}
}

// 사용
public class Example {
	public static void main(String[] args) {
		double result1 = 10 * 10 * Calculator.pi;       // 생성 없이 사용 가능
		int result2 = Calculator.plus(10, 5);
	}
}
```

- 주의

정적 메소드 내부에서 인스턴스 필드나 인스턴스 메소드를 사용할 수 없음. 또한 this도 사용 불가

사용하고 싶으면 정적 메소드 내부에서 new로 객체를 생성해야 함

## 싱글톤

프로그램 전체에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있음(하나 만드는데 리소스가 많이 필요한 경우 등). 이 객체를 싱글톤(Singleton)이라 함.

클래스 외부에서 new 연산자로 생성자를 호출할 수 없게 막아야 함.

이는 private 접근 제한자를 붙이면 됨

```java
public class Singleton {
	private static Singleton singleton = new Singleton();
	
	private Singleton() {}
	
	static Singleton getInstance() {
		return singleton;
	}
}

// 사용
public class Example {
	public static void main(String[] args) {
		// Singleton obj1 = new Singleton(); // 에러
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		
		s1 == s2; // true => 참조하는 객체가 같다는 뜻
	}
}
```

### EagerSingleton

프로그램 실행 시(클래스가 JVM에 로드될 때) static 영역에 eager, 힙 영역에 인스턴스가 바로 생김.

```java
public class EagerSingleton {
    private static EagerSingleton eager = new EagerSingleton();

    private EagerSingleton() {
    }

    public static EagerSingleton getInstance() {
        return eager;
    }
}
```

### LazySingleton

프로그램 실행 시 static 공간에 lazy는 생기지만 null이 들어가 있음. 근데 이제 호출할 때 생성되게 함.

```java
public class LazySingleton {
    private static LazySingleton lazy;

    private LazySingleton() {
    }

    public static LazySingleton getInstance() {
        if (lazy == null) lazy = new LazySingleton();

        return lazy;
    }
}
```

# 접근 제한자

클래스, 생성자, 필드, 메소드에 제한 가능

## public

외부에서도 자유롭게 접근 가능

## protected

같은 패키지 혹은 자식 클래스에서 접근 가능

## default

같은 패키지에 소속된 클래스에서만 접근 가능

## private

외부에서 접근 불가

## Getter / Setter

일반적으로 객체 지향에서는 객체의 필드를 객체 외부에서 직접 접근하는 것을 막는다.

객체의 무결성을 유지하기 위해.

따라서 필드를 private으로 생성하고 Getter나 Setter로 접근, 수정 한다.

```java
public class Car {
	private int speed;
	
	public int getSpeed() {
		return speed;
	}
	
	public void setSpeed(int speed) {
		if(speed < 0) {
			this.speed = 0;
			return;
		} else {
			this.speed = speed;
		}
	}
}
```

# Import

```java
// import 없이 타 패키지의 메소드를 사용하고 싶을 때
public class Application1 {
    public static void main(String[] args) {
        /* 설명. 다른 패키지에 있는 non-static 메소드를 가져오기 위해 선언  */
        com.ohgiraffers.section01.method.Calculator cal = new com.ohgiraffers.section01.method.Calculator();

        int result= cal.plusTwoNumbers(1, 2);
        System.out.println("result= " + result);
        
        /* 설명. 다른 패키지에 있는 static 메소드를 가져오기 위해 선언(new 필요 없음) */
        int minResult = com.ohgiraffers.section01.method.Calculator.minNumbersOf(1, 2);
    }
}

// import 사용해서 타 패키지의 메소드 사용
import com.ohgiraffers.section01.method.Calculator;

public class Application2 {
    public static void main(String[] args) {
        Calculator cal = new Calculator();

        int result = cal.plusTwoNumbers(10, 2);
        System.out.println("result = " + result);
    }
}

// 빌트인 메소드 사용 ex) Math
public class Application3 {
	 public static void main(String[] args) {
		 // 타 패키지에 있는 static 메소드기에 java.lang.Math를 다 표시해야 함
		 java.lang.Math.abs(-32.1);
		 
		 // 근데 Math는 import를 안 해도 됨
		 // 왜? java.lang 패키지는 생략 가능
		 // 왜? 기본적으로 자동으로 import 됨
		 // 왜? 자주 사용되는 애들을 그냥 기본적으로 import 해줌
		 Math.abs(-32.1);
	}
}
```

패키지는 클래스의 소속이다. 클래스를 명시할 때 원래는 패키지까지 다 써야 하지만 같은 패키지거나 import를 했을 경우는 편의상 생략 가능한 것.

# static import?

클래스의 정적 멤버(메서드 또는 변수)를 가져와서 클래스명을 생략하고 사용할 수 있도록 함

## 비교

```java
import java.lang.Math;

public class Example {
	public static void main(String[] args) {
		double result = Math.sqrt(16);
		System.out.println(result);
	}
}
```

```java
import static java.lang.Math.sqrt;

public class Example {
	public static void main(String[] args) {
		double result = sqrt(16); // Math 생략 가능
		System.out.println(result);
	}
}
```

> 주의 `import static`을 많이 사용하면 코드만 보고 어느 클래스에서 온 것인지 알기 어려워 가독성이 좋지 않다.

같은 이름의 클래스를 동시에 `import static`하면 충돌이 발생할 수 있다.