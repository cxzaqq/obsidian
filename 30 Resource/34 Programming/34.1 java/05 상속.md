# 개요

목적

이미 잘 개발된 클래스를 재사용해서 중복되는 코드를 줄인다.

부모 클래스 수정 시 자식 클래스에도 반영되므로 유지 보수의 시간도 최소화 가능

처음 탄생은 이런데 나중에 스파게티 코드 때문에 없어질 뻔 하다가 다형성에 사용돼서 아직 살아 있는 것이다.

A is a B가 성립하면 A가 자식 B가 부모임 ex) RacingCar is a Car

# 클래스 상속

`extends` 사용

특징

- 여러 개의 부모 클래스를 상속할 수 없음
- 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외(다른 패키지일 경우 default 제한도 상속에서 제외)
- final 클래스는 상속 불가
- 다른 패키지의 클래스는 상속 불가

자바에서 자식 객체를 생성하면 부모 객체가 먼저 생성되고 그 다음 자식 객체가 생성됨

즉 자식 객체를 생성하면 자동으로 부모 객체가 생성됨

어떻게 생성되는 것일까?

자식 생성자가 명시적으로 선언되지 않았다면 컴파일러가 자동으로 기본 생성자를 생성함

```java
public class DmbCellPhone extends CellPhone {
	public DmbCellPhone() {
		super();    // 부모의 기본 생성자 호출
	}
}
```

혹은 명시적으로 작성해도 됨.

⇒ 부모의 멤버를 상속받지만 부모의 생성자는 상속받지 않는다.

- 모든 클래스는 Object를 부모로 갖는다

즉 extends를 적지 않아도 자동으로 이렇게 적힘

```java
public class Car /*extends Object*/ { ... }
```

엄밀히 말하면 Car 객체 생성 전에 Object가 먼저 생성되고 Car가 생성됨

- deperecated? 없어질 수도 있으니 쓰지 마라 권장.

# 메소드 재정의(Overriding)

> 인텔리제이에서 ctrl + o 하면 재정의 가능한 메소드가 보인다.

상속된 일부 메소드를 자식 클래스에서 다시 수정해서 사용하는 경우를 오버라이딩이라 한다.

- 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수)를 가져야 함
- 접근 제한을 더 강하게 재정의 불가
- 새로운 예외를 throw할 수 없다.
- final 메소드 재정의 불가

재정의 시 부모의 메소드는 숨겨지기에 자식 객체에서 메소드 호출 시 재정의 된 메소드가 호출됨

만약 자식 객체에서 재정의 됐지만 기존 부모의 메소드를 호출하고 싶으면 super.으로 접근 가능

예시

```java
public class Cal {
	double areaCircle(double r) {
		return 3.14159 * r * r;
	}
}
```

```java

public class Computer extends Cal {
	@Override
	double areaCircle(double r) {
		return Math.PI * r * r;
	}
}
```

여기서 `@Override` 를 어노테이션이라 하는데 이는 생략 가능하나 명시적으로 넣어주는 게 좋다.

또한 부모의 메소드와 이름이 달라지면(휴먼 에러) 어노테이션에 에러가 뜬다.

## 접근 제어자와 오버라이딩

부모에서

private: 오버라이딩 불가

public이 붙어도 final이 있다면 오버라이딩 불가

protected: 상속이면 다른 패키지라도 오버라이딩 가능

default: 다른 패키지면 오버라이딩 불가

# 다형성

다양한 객체를 이용해서 다양한 실행 결과가 나오도록 하는 성질

메소드 재정의 + 타입 변환 ⇒ 다형성

## 자동 타입 변환

클래스도 자동 타입 변환이 있다.

부모 타입 변수에 자식 타입을 넣으면 부모 타입으로 자동 형 변환이 일어난다.

부모의 자식의 자식도 부모 타입으로 변환 가능

**주의**

> 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근 가능. 그러나 메소드가 자식 클래스에서 재정의 되었다면 자식 클래스의 메소드가 대신 호출됨.

```java
public class Parent {
	public void method1() {
		System.out.println("parent-method1");
	}
	
	public void method2() {
		System.out.println("parent-method2");
	}
}
```

```java
public class Child extends Parent {
	@Override
	public void method2() {
		System.out.println("child-method2");
	}
	
	public void method3() {
		System.out.println("child-method3");
	}
}
```

```java
public class ChildExample {
	public static void main(String[] args) {
		Child child = new Child();
		
		Parent parent = child; // 부모 타입으로 자동 형변환
		parent.method1(); // parent-method1
		parent.method2(); // child-method2
		// parent.method3(); // 호출 불가
	}
}
```

어쨌든 parent는 Parent 타입이기에 자식 메소드를 호출할 수 없는 것이다.

근데 왜 자식 타입에서 재정의된 메소드가 호출되는가?

그것은 동적 바인딩이 되었기 때문이다.

## 정적 바인딩

런타임 이전에 (부모)객체에 바인딩 됨

## 동적 바인딩?

런타임에 (자식)객체에 바인딩 됨

메소드 호출 시점(런타임)에 실제 객체 타입을 기준으로 실행할 메소드를 결정하는 것.

즉 위 경우에서 Parent 타입의 참조 변수 parent라도 실제로 Child 객체를 참조하고 있기 때문에 method2()를 호출하면 재정의된 메소드가 실행되는 것이다.

정적 메소드, private 메소드, final 메소드는 동적 바인딩이 적용되지 않는다.

동적 바인딩이 적용되는 이유?

자바에서 객체는 실제 타입과 참조 타입을 가질 수 있는데 메소드를 호출할 때는 항상 객체의 실제 타입을 기준으로 실행해야 하기 때문

위 예에서는 parent 변수의 타입은 Parent지만 실제 생성된 객체는 Child 이므로 runtime에 Child의 메소드를 호출해야 함. (parent의 실제 타입은 Child인 것)

이를 위해 JVM이 실행 중에 객체의 실제 타입을 확인하고 올바를 메소드를 호출하도록 동적 바인딩을 적용함.

동적 바인딩을 사용해야 다형성을 지원하여 코드의 확장성과 유연성을 높일 수 있다.

> 동적 바인드 조건

- 상속
- 오버라이딩
- 다형성

## 그렇다면 왜 자동 타입 변환이 필요할까?

그냥 자식 타입으로 사용하면 되는데 부모 타입으로 변환해서 사용하는 이유가 뭘까?

바로 다형성을 구현하기 위해서인데 필드의 타입을 부모 타입으로 선언하면 다양한 자식 객체들이 저장될 수 있기 때문에 필드 사용 결과가 달라질 수 있다.

## 매개 변수의 다형성

```java
class Driver {
	void drive(Vehicle vehicle) {
		vehicle.run();
	}
}
```

```java
Driver driver = new Driver();
Vehicle vehicle = new Vehicle();
driver.drive(vehicle);
```

만약 Vehicle의 자식 클래스인 Bus 객체를 drive() 메소드의 매개값으로 넘겨준다면?

```java
Driver driver = new Driver();
Bus bus = new Bus();
driver.drive(bus);
```

```java
Vehicle vehicle = bus; // 자동 타입 변환
```

```java
void drive(Vehicle vehicle) { // 여기에 자식 객체인 Bus bus가 들어옴
		vehicle.run(); // 자식에서 재정의한 run() 메소드가 실행됨
}
```

이렇게 매개 값의 자동 타입 변환과 메소드의 재정의를 이용해서 매개 변수의 다형성을 구현 가능

## 강제 타입 변환

부모 타입을 자식 타입으로 변환하는 것.

자식 타입이 부모 타입으로 자동 타입 변환 후 다시 자식 타입으로 변환할 때 강제 타입 변환 사용 가능

```java
Parent parent = new Child();   // 자동 타입 변환
Child child = (Child) parent;  // 강제 타입 변환
```

자동 변환 되면 부모 타입의 메소드만 사용 가능하다는 제약이 생기는데 자식에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환으로 다시 자식 타입으로 변환하여 사용 가능.

강제 타입 변환은 자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능하기 때문에 다음과 같이 처음부터 부모 타입으로 생성된 객체는 자식 타입으로 변환 불가.

```java
Parent parent = new Parent();
Child child = (Child) parent; // 불가
```

그렇다면 현재 부모 변수가 참조하는 객체가 부모 객체인지 자식 객체인지 확인해야 하는데 이는 `instancof`연산자를 사용하면 된다.

```java
public void method(Parent parent) {
	if(parent instanceof Child) { // parent가 Child를 참조하는지
		Child child = (Child) parent;
	}
}
```

> 주의

```java
// 부모 A
public class A {
	public void methodA() { ... }
}
```

```java
// 자식 B
public class B extends A {
	public void methodB() { ... }
}
```

```java
// 자식 C
public class C extends A {
	public void methodC() { ... }
}
```

```java
public class Test {
	public static void main(Stirng[] args) {
		A a1 = new A();
		A a2 = new B();
		A a3 = new C();
		
		/*
		코드상 오류는 없지만 런타임에 에러남. a2의 실제 객체는 B인데
		이건 런타임에 동적 바인딩 되기 때문
		강제 변환 시 instanceof 꼭 사용하자
		*/
		((C)a2).methodC();
	}	
}
```

# 추상 클래스

실체 클래스의 공통적인 특성(필드, 메소드)을 뽑아내어 추상 클래스로 만드는 이유가 뭘까?

- 공통된 필드와 메솓의 이름을 통일

데이터와 기능이 동일함에도 불구하고 이름이 다르면 객체마다 사용 방법이 달라져서 불편함. 추상 클래스로 공통된 부분을 통일하는 게 좋음

- 실체 클래스를 작성할 때 시간 절약

추상 클래스를 상속 받기에 추가되는 부분만 작성하면 됨

근데 개발자가 사용할 일은 거의 없다. API에 사용됨

## 추상 클래스 선언

```java
public abstract class Example { ... }
```

추상 클래스도 마찬가지로 필드, 생성자, 메소드 선언을 할 수 있다.

new 연산자로 직접 생성자를 호출할 수는 없지만 자식 객체가 생성될 때 spuer(…)를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 있어야 함.

```java
public abstract class Phone {
	public String owner;
	
	public Phone(String owner) {
		this.owner = owner;
	}
	
	public void turnOn() {
		System.out.println("전원 ON");
	}
	public void turnOff() {
		System.out.println("전원 OFF");
	}
}
```

```java
public class SmartPhone extends Phone {
	public SmartPhone(String owner) {
		super(owner);
	}
	
	public void internetSearch() {
		System.out.println("인터넷 서칭..");
	}
}
```

```java
public class Example {
	public static void main(Stringp[] args) {
		// Phone phone = new Phone(); // 불가
		
		SmartPhone smartPhone = new SmartPhone("roy");
		
		smartPhone.turnOn(); // 가능
	}
}
```

## 추상 메소드와 재정의

추상 클래스 설계 시 하위 클래스가 반드시 실행 내용을 채우도록 강제하고 싶은 메소드가 있을 경우 해당 메소드를 추상 메소드로 선언.

이때 자식 클래스는 반드시 추상 메소드를 재정의해야 하는데 그렇지 않으면 컴파일 에러가 발생

```java
public abstract class Animal {
	public String kind;
	
	public abstract void sound(); // 추상 메소드
}
```

```java
public calss Dog extends Animal {
	public Dog() {
		this.kind = "포유류";
	}
	
	@Overrid                       // 이 부분이 없으면 컴파일 에러
	public void sound() {
		System.out.println("멍멍");
	}
}
```

# 오버로딩 vs 오버라이딩

| 오버라이딩                                           | 오버로딩                                |
| ----------------------------------------------- | ----------------------------------- |
| 하위 클래스에서 메소드 정의                                 | 같은 클래스에서 메소드 정의                     |
| 메소드 이름 동일<br>매개변수 동일(개수, 타입, 순서)<br>리턴 타입 동일    | 메소드 이름 동일<br>매개변수 다름<br>리턴 타입 상관 없음 |
| 자식 메소드의 접근 범위가 부모 메소드의 접근 범위보다 넓거나 같아야 함        | 접근 제어자와 상관 없음                       |
| 자식 메소드의 예외 처리 수가 부모 메소드의 예외 처리 수보다 적거나 범위 좁아야 함 | 예외 처리와 상관 없음                        |
